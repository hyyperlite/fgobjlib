<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>fgobjlib.fg_vpn_ipsec_p1_interface API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fgobjlib.fg_vpn_ipsec_p1_interface</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from fgobjlib import FgObject
import ipaddress

class FgIpsecP1Interface(FgObject):
    &#34;&#34;&#34; FgIpsecP1Interface class represents FortiGate Firewall ipsec phase1 interface object and provides methods for
    validating parameters and generating both cli and api configuration data for use in external configuration
    applications

    Currently supports dynamic or static VPN using psk authentication. No support yet for advpn or mode-cfg

    Attributes:
        name (str): Name of ipsec phase1-interface object
        p1_type (str): Phase1-interface type
        local_intf (str): Name of locally attached fortigate interface
        proposal (list): Phase1-interface proposal(s)
        ike_version (int): ike version
        local_gw (str): Phase1-interface local-gw IP
        psk (str): Pre-shared key
        local_id (str): Local ID
        remote_gw (str): Remote Gateway
        add_route (bool):  add-route (True=enable, False=disable, None=inherit)
        add_gw_route (bool): add-gw-route (True=enable, False=disable, None=inherit)
        keepalive (int): Keepalive in seconds
        net_device (bool): net-device (True=enable, False=disable, None=inherit)
        comment (str): phase1 comment
        vdom (str): Associated VDOM, if applicable
        tunnel_search (str):  tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
        dpd (str): phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
        dhgrp (str): dhgrp
        nattraversal (str): nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
        exchange_interface_ip: exchange-interface-ip (True=enable, False=disable, None=inherit)
    &#34;&#34;&#34;

    def __init__(self, name: str = None, p1_type: str = None, local_intf: str = None, proposal: list = None,
                 ike_version: int = None, local_gw: str = None, psk: str = None, local_id: str = None,
                 remote_gw: str = None, add_route: bool = None, add_gw_route: bool = None, keepalive: int = None,
                 net_device: bool = None, comment: str = None, vdom: str = None,  tunnel_search: str = None,
                 dpd: str = None, dhgrp: list = None, nattraversal: str = None, exchange_interface_ip: bool = None):

        &#34;&#34;&#34;
        Args:
            name (str): Set name of ipsec phase1-interface object
            p1_type (str): Set phase1-interface type
            local_intf (str): Set name of locally attached fortigate interface
            proposal (list): Set phase1-interface proposal(s)
            ike_version (int): Set ike version
            local_gw (str): Set phase1-interface local-gw IP
            psk (str): Set pre-shared key
            local_id (str): Set local ID
            remote_gw (str): Set remote Gateway
            add_route (bool):  Set add-route (True=enable, False=disable, None=inherit)
            add_gw_route (bool): Set add-gw-route (True=enable, False=disable, None=inherit)
            keepalive (int): Set keepalive in seconds
            net_device (bool): Set net-device (True=enable, False=disable, None=inherit)
            comment (str): Set phase1 comment
            vdom (str): Set associated VDOM, if applicable
            tunnel_search (str):  Set tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
            dpd (list): Set phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
            nattraversal (str): Set nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
            exchange_interface_ip: Set exchange-interfce-ip (True=enable, False=disable, None=inherit)
        &#34;&#34;&#34;

        # Initialize the parent class
        super().__init__(api=&#39;cmdb&#39;, api_path=&#39;vpn.ipsec&#39;, api_name=&#39;phase1-interface&#39;,
                         cli_path=&#34;config vpn ipsec phase1-interface&#34;, obj_id=name, vdom=vdom)

        ### Set parent class attributes ###
        # CLI config path for this object type
        self.cli_path = &#34;config vpn ipsec phase1-interface&#34;

        # Map instance attribute names to fg attribute names
        self.data_attrs = {&#39;name&#39;: &#39;name&#39;, &#39;p1_type&#39;: &#39;type&#39;, &#39;local_intf&#39;: &#39;interface&#39;, &#39;proposal&#39;: &#39;proposal&#39;,
                           &#39;ike_version&#39;: &#39;ike-version&#39;, &#39;local_gw&#39;: &#39;local-gw&#39;, &#39;psk&#39;: &#39;psksecret&#39;,
                           &#39;local_id&#39;: &#39;localid&#39;, &#39;remote_gw&#39;: &#39;remote-gw&#39;, &#39;comment&#39;: &#39;comments&#39;,
                           &#39;add_route&#39;: &#39;add-route&#39;, &#39;add_gw_route&#39;: &#39;add-gw-route&#39;, &#39;keepalive&#39;: &#39;keepalive&#39;,
                           &#39;net_device&#39;: &#39;net-device&#39;, &#39;tunnel_search&#39;: &#39;tunnel-search&#39;, &#39;dpd&#39;: &#39;dpd&#39;, &#39;dhgrp&#39;: &#39;dhgrp&#39;,
                           &#39;nattraversal&#39;: &#39;nattraversal&#39;, &#39;exchange_interface_ip&#39;: &#39;exchange-interface-ip&#39;}

        self.cli_ignore_attrs = [&#39;name&#39;]

        # Set instance attributes
        self.set_name(name)
        self.set_p1_type(p1_type)
        self.set_local_intf(local_intf)
        self.set_proposal(proposal)
        self.set_ike_version(ike_version)
        self.set_local_gw(local_gw)
        self.set_psk(psk)
        self.set_local_id(local_id)
        self.set_remote_gw(remote_gw)
        self.set_vdom(vdom)
        self.set_comment(comment)
        self.set_add_route(add_route)
        self.set_keepalive(keepalive)
        self.set_add_gw_route(add_gw_route)
        self.set_net_device(net_device)
        self.set_tunnel_search(tunnel_search)
        self.set_dpd(dpd)
        self.set_dhgrp(dhgrp)
        self.set_nattraversal(nattraversal)
        self.set_exchange_interface_ip(exchange_interface_ip)


    def set_name(self, name):
        &#34;&#34;&#34; Set self.name to name if name is valid

        Args:
            name: Name of object

        Returns:
            None
        &#34;&#34;&#34;
        if name:
            if name.isspace(): raise Exception(&#34;\&#34;name\&#34;, cannot be an empty string&#34;)
            if isinstance(name, str):
                if len(name) &lt;= 35:
                    self.name = name
                else:
                    raise Exception(&#34;\&#34;name\&#34;, must be less than 35 chars or less&#34;)
            else:
                raise Exception(&#34;\&#34;name\&#34;, must be a string&#34;)
        else:
            raise Exception(&#34;Value \&#34;name\&#34; is required but was not provided&#34;)

    def set_proposal(self, proposal):
        &#34;&#34;&#34; Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals

        Args:
            proposal (list): string containing a single p1 proposal or list of strings with one or more p1 propolsals

        Returns:
            None
        &#34;&#34;&#34;
        valid_proposals = [&#39;des-md5&#39;, &#39;des-sha&#39;, &#39;des-sha256&#39;, &#39;des-sha384&#39;, &#39;des-sha512&#39;, &#39;3des-md5&#39;, &#39;3des-sha1&#39;,
                           &#39;3des-sha256&#39;, &#39;3des-sha384&#39;, &#39;3des-sha512&#39;, &#39;aes128-md5&#39;, &#39;aes128-sha1&#39;, &#39;aes128-sha256&#39;,
                           &#39;aes128-sha384&#39;, &#39;aes128-sha512&#39;, &#39;aes192-md5&#39;, &#39;aes192-sha1&#39;, &#39;aes192-sha256&#39;,
                           &#39;aes192-sha384&#39;, &#39;aes192-sha512&#39;, &#39;aes256-md5&#39;, &#39;aes256-sha1&#39;, &#39;aes256-sha256&#39;,
                           &#39;aes256-sha384&#39;, &#39;aes256-sha512&#39;, &#39;aria128-md5&#39;, &#39;aria128-sha1&#39;, &#39;aria128-sha256&#39;,
                           &#39;aria128-sha384&#39;, &#39;aria128-sha512&#39;, &#39;aria192-md5&#39;, &#39;aria192-sha1&#39;, &#39;aria192-sha256&#39;,
                           &#39;aria192-sha384&#39;, &#39;aria192-sha512&#39;, &#39;aria256-md5&#39;, &#39;aria256-sha1&#39;, &#39;aria256-sha256&#39;,
                           &#39;aria256-sha384&#39;, &#39;aria256-sha512&#39;, &#39;seed-md5&#39;, &#39;seed-sha1&#39;, &#39;seed-sha256&#39;, &#39;seed-sha384&#39;,
                           &#39;seed-sha512&#39;]

        if proposal:
            proposal_items = &#39;&#39;

            # IF a single object was passed as a string, append it to intf_list else iterate the list and pull
            # out the strings of interfaces and append each to intf_list
            if isinstance(proposal, str):

                # compare proposal to valid_proposals list
                if proposal in valid_proposals:
                    proposal_items += &#34;{} &#34;.format(proposal)
                else:
                    raise Exception(&#34;\&#34;proposal\&#34; provided: {} is not a valid fortigate phase1 proposal &#34;
                                    &#34;option&#34;.format(proposal))

            elif isinstance(proposal, list):
                for item in proposal:
                    if isinstance(item, str):

                        # compare proposal to valid proposals list
                        if item in valid_proposals:
                            proposal_items += &#34;{} &#34;.format(item)
                        else:
                            raise Exception(&#34;\&#34;proposal\&#34; provided: {} is not a valid fortigate phase1 proposal &#34;
                                            &#34;option&#34;.format(proposal))
            else:
                raise Exception(&#34;proposal must be provided as type string (with single proposal referenced or as a &#34;
                                &#34;list for multiple proposal references&#34;)

            self.proposal = proposal_items

        else:
            self.proposal = None

    def set_dhgrp(self, dhgrp):
        &#34;&#34;&#34; Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp

        The dhgrp may be passed in as a str, or a list.  If the dhgrp(s) passed in are valid, add each
        of those to a space separated values string and set in self.dhgrp

        Args:
            dhgrp (list): single int representing one dhgrp or a list of ints for one or more dhgrps

        Returns:
            None
        &#34;&#34;&#34;
        if dhgrp:
            dhgrp_items = &#39;&#39;
            valid_dhgrps = [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 27, 28, 30, 31, 32]

            # IF a single object was passed as a string, append it to list else iterate the list and pull
            # out the dhgrps and add to list to be set as self object
            if isinstance(dhgrp, int):
                # compare proposal to valid_list
                if dhgrp in valid_dhgrps:
                    dhgrp_items += &#34;{} &#34;.format(dhgrp)
                else:
                    raise Exception(&#34;\&#34;dhgrp\&#34; provided: \&#34;{}\&#34;, is not a valid fortigate dhgrp&#34;.format(dhgrp))

            elif isinstance(dhgrp, list):
                for item in dhgrp:
                    if isinstance(item, int):

                        # compare proposal to valid proposals list
                        if item in valid_dhgrps:
                            dhgrp_items += &#34;{} &#34;.format(item)
                        else:
                            raise Exception(&#34;At least one \&#34;dhgrp\&#34; provided: {} is not a valid fortigate phase1 &#34;
                                            &#34;proposal option&#34;.format(dhgrp))
            else:
                raise Exception(&#34;dhgrp must be provided as type integer&#34;)

            self.dhgrp = dhgrp_items

        else:
            self.dhgrp = None

    def set_p1_type(self, p1_type):
        &#34;&#34;&#34; Set self.pt_type to p1_type if p1_type is valid

        Args:
            p1_type (str): Phase1-interface type.  May be: &#39;dynamic&#39;, &#39;static&#39;, &#39;ddns&#39; or None=inherit

        Returns:

        &#34;&#34;&#34;
        if p1_type:
            if isinstance(p1_type, str):
                if p1_type.lower() == &#39;dynamic&#39;:
                    self.p1_type = &#39;dynamic&#39;
                elif p1_type.lower() == &#39;static&#39;:
                    self.p1_type = &#39;static&#39;
                elif p1_type.lower() == &#39;ddns&#39;:
                    raise Exception(&#34;p1_type of \&#34;ddns\&#34; is not yet supported&#34;)
                else:
                    raise Exception(&#34;\&#34;p1_type\&#34;: {} is not supported&#34;.format(p1_type))
            else:
                raise Exception(&#34;\&#34;p1_type\&#34; when set must be a str with value \&#34;dynamic\&#34; or \&#34;static\&#34;&#34;)
        else:
            self.p1_type = None

    def set_local_intf(self, intf):
        &#34;&#34;&#34; set self.local_intfs to intf if intfs is valid

        Args:
            intf (str): Local interface for p1 attachment

        Returns:
            None
        &#34;&#34;&#34;
        if intf:
            if intf.isspace(): raise Exception(&#34;\&#34;local_intf\&#34;, cannot be an empty string&#34;)
            if isinstance(intf, str):
                if len(intf) &lt; 35:
                    self.local_intf = intf
                else:
                    raise Exception(&#34;\&#34;local_intf\&#34;, must be less than 35 chars or less&#34;)
            else:
                raise Exception(&#34;\&#34;local_intf\&#34;, must be a string&#34;)
        else:
            raise Exception(&#34;\&#34;local_intf\&#34; not set, phase1 requires to define the interface&#34;)

    def set_ike_version(self, ike_version):
        &#34;&#34;&#34; Set self.ike_version to 1 or 2 if ike_version = 1 or 2.  Otherwise raise Exception

        Args:
            ike_version (int): ike-version.  May be 1 or 2.

        Returns:
            None
        &#34;&#34;&#34;
        if ike_version:
            if isinstance(ike_version, int):
                if ike_version == 1:
                    self.ike_version = 1
                elif ike_version == 2:
                    self.ike_version = 2
                else:
                    raise Exception(&#34;\&#34;ike_version\&#34;, when set must be type int with value = \&#34;1\&#34; or \&#34;2\&#34;&#34;)
            else:
                raise Exception(&#34;\&#34;ike_version\&#34; when set, must be type int with value = \&#34;1\&#34; or \&#34;2\&#34;&#34;)
        else:
            self.ike_version = None

    def set_local_gw(self, local_gw):
        &#34;&#34;&#34; Set self.local_gw to local_gw if local_gw is valid ipv4 address

        Args:
            local_gw (str): Local gateway.  Must be valid ipv4 address

        Returns:
            None
        &#34;&#34;&#34;
        if local_gw:
            try:
                ipaddress.ip_address(local_gw)
            except ValueError:
                print(&#34;\&#34;local_gw\&#34;, must be a valid ipv4 or ipv6 address&#34;)
            else:
                self.local_gw = local_gw
        else:
            self.local_gw = None

    def set_remote_gw(self, remote_gw):
        &#34;&#34;&#34; Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address

        Args:
            remote_gw (str): Address of remote vpn peer gateway.  Must be valid ipv4 address.

        Returns:
            None
        &#34;&#34;&#34;
        if remote_gw:
            try:
                ipaddress.ip_address(remote_gw)
            except ValueError:
                print(&#34;\&#34;remote_gw\&#34;, must be a valid ipv4 address&#34;)
            else:
                self.remote_gw = remote_gw
        else:
            if self.p1_type == &#39;dynamic&#39;:
                self.remote_gw = None
            else:
                raise Exception(&#34;\&#34;remote_gw\&#34; not set, static tunnel types require a remote gateway&#34;)

    def set_psk(self, psk):
        &#34;&#34;&#34; Set self.psk to psk if psk valid

        Args:
            psk (str): Phase1 psksecret.  Must be between 6 and 30 chars.

        Returns:
            None
        &#34;&#34;&#34;
        print(&#34;*** {} ***&#34;.format(psk))
        if psk:
            if isinstance(psk, str):
                if 6 &lt;= len(psk) &lt;= 30:
                    self.psk = psk
                else:
                    raise Exception(&#34;\&#34;psk\&#34;, must be an str between 6 and 30 chars&#34;)
            else:
                raise Exception(&#34;\&#34;psk\&#34;, must be a string&#34;)
        else:
            raise Exception(&#34;\&#34;psk\&#34; is required but was not provided&#34;)

    def set_local_id(self, local_id):
        &#34;&#34;&#34; Set self.local_id to local_id if local_id is valid

        Args:
            local_id (str): Phase1 local id

       Returns:
            None
        &#34;&#34;&#34;
        if local_id:
            if isinstance(local_id, str):
                if 1 &lt;= len(local_id) &lt;= 63:
                    self.local_id = local_id
                else:
                    raise Exception(&#34;\&#34;local_id\&#34;, when set, must be type str between 1 and 63 chars&#34;)
            else:
                raise Exception(&#34;\&#34;local_id\&#34;, when set, must be type str&#34;)
        else:
            self.local_id = None

    def set_comment(self, comment):
        &#34;&#34;&#34; Set self.comment to comment if comment is valid

        Args:
            comment (str): Phase1 comment

        Returns:
            None
        &#34;&#34;&#34;
        if comment:
            if isinstance(comment, str):
                if 1 &lt;= len(comment) &lt;= 1023:
                    self.comment = comment
                else:
                    raise Exception(&#34;\&#34;description\&#34;, when set, must be type str between 1 and 1,023 chars&#34;)
            else:
                raise Exception(&#34;\&#34;description\&#34;, when set, must be type str&#34;)
        else:
            self.comment = None

    def set_keepalive(self, keepalive):
        &#34;&#34;&#34; Set self.keepalive if keepalive valid

        Args:
            keepalive (int): phase1 keepalive

        Returns:
            None
        &#34;&#34;&#34;
        if keepalive:
            if isinstance(keepalive, int):
                if 10 &lt;= keepalive &lt;= 900:
                    self.keepalive = keepalive
                else:
                    raise Exception(&#34;\&#34;keepalive\&#34;, when set, must be type int between 10 and 900&#34;)
            else:
                raise Exception(&#34;\&#34;keepalive\&#34;, when set, must be type int&#34;)
        else:
            self.keepalive = None

    def set_add_route(self, add_route):
        &#34;&#34;&#34; Set self.add_route

        Args:
            add_route (bool): add-route. (True=enable, False=Disable, None=inherit)

        Returns:

        &#34;&#34;&#34;
        if isinstance(add_route, bool):
            self.add_route = &#39;enable&#39; if add_route else &#39;disable&#39;
        else:
            self.add_route = None

    def set_add_gw_route(self, add_gw_route):
        &#34;&#34;&#34; Set self.add_gw_route

        Args:
            add_gw_route (bool): add-gw-route.  (True=enable, False=Disable, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(add_gw_route, bool):
            self.add_gw_route = &#39;enable&#39; if add_gw_route else &#39;disable&#39;
        else:
            self.add_gw_route = None

    def set_net_device(self, net_device):
        &#34;&#34;&#34; set self.net_device

        Args:
            net_device (bool): net-device.  (True=enable, False=Disable, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(net_device, bool):
            self.net_device = &#39;enable&#39; if net_device else &#39;disable&#39;
        else:
            self.net_device = None

    def set_tunnel_search(self, tunnel_search):
        &#34;&#34;&#34; Set self.tunnel_search

        Args:
            tunnel_search (str): tunnel-search.  (&#39;selectors&#39;, &#39;nexthop&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(tunnel_search, str):
            if tunnel_search.lower() == &#39;selectors&#39;:
                self.tunnel_search = &#39;selectors&#39;
            elif tunnel_search.lower() == &#39;nexthop&#39;:
                self.tunnel_search = &#39;nexthop&#39;
            else:
                raise Exception(&#34;\&#34;tunnel_search\&#34; was specified but is not value \&#34;selectors\&#34; or &#34;
                                &#34;\&#34;nexthop\&#34; as requried&#34;)
        else:
            self.tunnel_search = None

    def set_dpd(self, dpd):
        &#34;&#34;&#34; Set self.dpd

        Args:
            dpd (str): phase1 dpd.   (&#39;disable&#39;, &#39;on-idle&#39;, &#39;on-demand&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(dpd, str):
            if dpd.lower() == &#39;disable&#39;:
                self.dpd = &#39;disable&#39;
            elif dpd.lower() == &#39;on-idle&#39;:
                self.dpd = &#39;on-idle&#39;
            elif dpd.lower == &#39;on-demand&#39;:
                self.dpd = &#39;on-demand&#39;
            else:
                raise Exception(&#34;\&#34;dpd\&#34; was specied but is not value \&#34;disable\&#34;, \&#34;on-idle\&#34; or \&#34;on-demmand\&#34;&#34;
                                &#34;as required&#34;)
        else:
            self.dpd = None

    def set_nattraversal(self, nattraversal):
        &#34;&#34;&#34; Set self.nat_traversal

        Args:
            nattraversal (str): nat-traversal.  (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(nattraversal, str):
            if nattraversal.lower() == &#39;enable&#39;:
                self.nattraversal = &#39;enable&#39;
            elif nattraversal.lower() == &#39;disable&#39;:
                self.nattraversal = &#39;disable&#39;
            elif nattraversal.lower() == &#39;forced&#39;:
                self.nattraversal = &#39;forced&#39;
            else:
                raise Exception(&#34;\&#34;nattraversal\&#34; when set, must be a string value of \&#34;enable\&#34;, &#34;
                                &#34;\&#34;disable\&#34; or \&#34;forced\&#34;&#34;)
        else:
            self.nattraversal = None

    def set_exchange_interface_ip(self, exchange_interface_ip):
        &#34;&#34;&#34; Set self.exchange_interface_ip

        Args:
            exchange_interface_ip (bool): exchange-interface-ip. (True=enable, False=Disable, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(exchange_interface_ip, bool):
            self.exchange_interface_ip = &#39;enable&#39; if exchange_interface_ip else &#39;disable&#39;
        else:
            self.exchange_interface_ip = None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface"><code class="flex name class">
<span>class <span class="ident">FgIpsecP1Interface</span></span>
<span>(</span><span>name=None, p1_type=None, local_intf=None, proposal=None, ike_version=None, local_gw=None, psk=None, local_id=None, remote_gw=None, add_route=None, add_gw_route=None, keepalive=None, net_device=None, comment=None, vdom=None, tunnel_search=None, dpd=None, dhgrp=None, nattraversal=None, exchange_interface_ip=None)</span>
</code></dt>
<dd>
<section class="desc"><p>FgIpsecP1Interface class represents FortiGate Firewall ipsec phase1 interface object and provides methods for
validating parameters and generating both cli and api configuration data for use in external configuration
applications</p>
<p>Currently supports dynamic or static VPN using psk authentication. No support yet for advpn or mode-cfg</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of ipsec phase1-interface object</dd>
<dt><strong><code>p1_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1-interface type</dd>
<dt><strong><code>local_intf</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of locally attached fortigate interface</dd>
<dt><strong><code>proposal</code></strong> :&ensp;<code>list</code></dt>
<dd>Phase1-interface proposal(s)</dd>
<dt><strong><code>ike_version</code></strong> :&ensp;<code>int</code></dt>
<dd>ike version</dd>
<dt><strong><code>local_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1-interface local-gw IP</dd>
<dt><strong><code>psk</code></strong> :&ensp;<code>str</code></dt>
<dd>Pre-shared key</dd>
<dt><strong><code>local_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Local ID</dd>
<dt><strong><code>remote_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Remote Gateway</dd>
<dt><strong><code>add_route</code></strong> :&ensp;<code>bool</code></dt>
<dd>add-route (True=enable, False=disable, None=inherit)</dd>
<dt><strong><code>add_gw_route</code></strong> :&ensp;<code>bool</code></dt>
<dd>add-gw-route (True=enable, False=disable, None=inherit)</dd>
<dt><strong><code>keepalive</code></strong> :&ensp;<code>int</code></dt>
<dd>Keepalive in seconds</dd>
<dt><strong><code>net_device</code></strong> :&ensp;<code>bool</code></dt>
<dd>net-device (True=enable, False=disable, None=inherit)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>phase1 comment</dd>
<dt><strong><code>vdom</code></strong> :&ensp;<code>str</code></dt>
<dd>Associated VDOM, if applicable</dd>
<dt><strong><code>tunnel_search</code></strong> :&ensp;<code>str</code></dt>
<dd>tunnel-search ('next-hop', 'selectors' or None=inherit)</dd>
<dt><strong><code>dpd</code></strong> :&ensp;<code>str</code></dt>
<dd>phase1 DPD ('on-demand', 'on-idle', 'disable' or None=inherit)</dd>
<dt><strong><code>dhgrp</code></strong> :&ensp;<code>str</code></dt>
<dd>dhgrp</dd>
<dt><strong><code>nattraversal</code></strong> :&ensp;<code>str</code></dt>
<dd>nattraversal ('enable', 'disable', 'forced' or None=inherit)</dd>
<dt><strong><code>exchange_interface_ip</code></strong></dt>
<dd>exchange-interface-ip (True=enable, False=disable, None=inherit)</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Set name of ipsec phase1-interface object</dd>
<dt><strong><code>p1_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Set phase1-interface type</dd>
<dt><strong><code>local_intf</code></strong> :&ensp;<code>str</code></dt>
<dd>Set name of locally attached fortigate interface</dd>
<dt><strong><code>proposal</code></strong> :&ensp;<code>list</code></dt>
<dd>Set phase1-interface proposal(s)</dd>
<dt><strong><code>ike_version</code></strong> :&ensp;<code>int</code></dt>
<dd>Set ike version</dd>
<dt><strong><code>local_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Set phase1-interface local-gw IP</dd>
<dt><strong><code>psk</code></strong> :&ensp;<code>str</code></dt>
<dd>Set pre-shared key</dd>
<dt><strong><code>local_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Set local ID</dd>
<dt><strong><code>remote_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Set remote Gateway</dd>
<dt><strong><code>add_route</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set add-route (True=enable, False=disable, None=inherit)</dd>
<dt><strong><code>add_gw_route</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set add-gw-route (True=enable, False=disable, None=inherit)</dd>
<dt><strong><code>keepalive</code></strong> :&ensp;<code>int</code></dt>
<dd>Set keepalive in seconds</dd>
<dt><strong><code>net_device</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set net-device (True=enable, False=disable, None=inherit)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Set phase1 comment</dd>
<dt><strong><code>vdom</code></strong> :&ensp;<code>str</code></dt>
<dd>Set associated VDOM, if applicable</dd>
<dt><strong><code>tunnel_search</code></strong> :&ensp;<code>str</code></dt>
<dd>Set tunnel-search ('next-hop', 'selectors' or None=inherit)</dd>
<dt><strong><code>dpd</code></strong> :&ensp;<code>list</code></dt>
<dd>Set phase1 DPD ('on-demand', 'on-idle', 'disable' or None=inherit)</dd>
<dt><strong><code>nattraversal</code></strong> :&ensp;<code>str</code></dt>
<dd>Set nattraversal ('enable', 'disable', 'forced' or None=inherit)</dd>
<dt><strong><code>exchange_interface_ip</code></strong></dt>
<dd>Set exchange-interfce-ip (True=enable, False=disable, None=inherit)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FgIpsecP1Interface(FgObject):
    &#34;&#34;&#34; FgIpsecP1Interface class represents FortiGate Firewall ipsec phase1 interface object and provides methods for
    validating parameters and generating both cli and api configuration data for use in external configuration
    applications

    Currently supports dynamic or static VPN using psk authentication. No support yet for advpn or mode-cfg

    Attributes:
        name (str): Name of ipsec phase1-interface object
        p1_type (str): Phase1-interface type
        local_intf (str): Name of locally attached fortigate interface
        proposal (list): Phase1-interface proposal(s)
        ike_version (int): ike version
        local_gw (str): Phase1-interface local-gw IP
        psk (str): Pre-shared key
        local_id (str): Local ID
        remote_gw (str): Remote Gateway
        add_route (bool):  add-route (True=enable, False=disable, None=inherit)
        add_gw_route (bool): add-gw-route (True=enable, False=disable, None=inherit)
        keepalive (int): Keepalive in seconds
        net_device (bool): net-device (True=enable, False=disable, None=inherit)
        comment (str): phase1 comment
        vdom (str): Associated VDOM, if applicable
        tunnel_search (str):  tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
        dpd (str): phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
        dhgrp (str): dhgrp
        nattraversal (str): nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
        exchange_interface_ip: exchange-interface-ip (True=enable, False=disable, None=inherit)
    &#34;&#34;&#34;

    def __init__(self, name: str = None, p1_type: str = None, local_intf: str = None, proposal: list = None,
                 ike_version: int = None, local_gw: str = None, psk: str = None, local_id: str = None,
                 remote_gw: str = None, add_route: bool = None, add_gw_route: bool = None, keepalive: int = None,
                 net_device: bool = None, comment: str = None, vdom: str = None,  tunnel_search: str = None,
                 dpd: str = None, dhgrp: list = None, nattraversal: str = None, exchange_interface_ip: bool = None):

        &#34;&#34;&#34;
        Args:
            name (str): Set name of ipsec phase1-interface object
            p1_type (str): Set phase1-interface type
            local_intf (str): Set name of locally attached fortigate interface
            proposal (list): Set phase1-interface proposal(s)
            ike_version (int): Set ike version
            local_gw (str): Set phase1-interface local-gw IP
            psk (str): Set pre-shared key
            local_id (str): Set local ID
            remote_gw (str): Set remote Gateway
            add_route (bool):  Set add-route (True=enable, False=disable, None=inherit)
            add_gw_route (bool): Set add-gw-route (True=enable, False=disable, None=inherit)
            keepalive (int): Set keepalive in seconds
            net_device (bool): Set net-device (True=enable, False=disable, None=inherit)
            comment (str): Set phase1 comment
            vdom (str): Set associated VDOM, if applicable
            tunnel_search (str):  Set tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
            dpd (list): Set phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
            nattraversal (str): Set nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
            exchange_interface_ip: Set exchange-interfce-ip (True=enable, False=disable, None=inherit)
        &#34;&#34;&#34;

        # Initialize the parent class
        super().__init__(api=&#39;cmdb&#39;, api_path=&#39;vpn.ipsec&#39;, api_name=&#39;phase1-interface&#39;,
                         cli_path=&#34;config vpn ipsec phase1-interface&#34;, obj_id=name, vdom=vdom)

        ### Set parent class attributes ###
        # CLI config path for this object type
        self.cli_path = &#34;config vpn ipsec phase1-interface&#34;

        # Map instance attribute names to fg attribute names
        self.data_attrs = {&#39;name&#39;: &#39;name&#39;, &#39;p1_type&#39;: &#39;type&#39;, &#39;local_intf&#39;: &#39;interface&#39;, &#39;proposal&#39;: &#39;proposal&#39;,
                           &#39;ike_version&#39;: &#39;ike-version&#39;, &#39;local_gw&#39;: &#39;local-gw&#39;, &#39;psk&#39;: &#39;psksecret&#39;,
                           &#39;local_id&#39;: &#39;localid&#39;, &#39;remote_gw&#39;: &#39;remote-gw&#39;, &#39;comment&#39;: &#39;comments&#39;,
                           &#39;add_route&#39;: &#39;add-route&#39;, &#39;add_gw_route&#39;: &#39;add-gw-route&#39;, &#39;keepalive&#39;: &#39;keepalive&#39;,
                           &#39;net_device&#39;: &#39;net-device&#39;, &#39;tunnel_search&#39;: &#39;tunnel-search&#39;, &#39;dpd&#39;: &#39;dpd&#39;, &#39;dhgrp&#39;: &#39;dhgrp&#39;,
                           &#39;nattraversal&#39;: &#39;nattraversal&#39;, &#39;exchange_interface_ip&#39;: &#39;exchange-interface-ip&#39;}

        self.cli_ignore_attrs = [&#39;name&#39;]

        # Set instance attributes
        self.set_name(name)
        self.set_p1_type(p1_type)
        self.set_local_intf(local_intf)
        self.set_proposal(proposal)
        self.set_ike_version(ike_version)
        self.set_local_gw(local_gw)
        self.set_psk(psk)
        self.set_local_id(local_id)
        self.set_remote_gw(remote_gw)
        self.set_vdom(vdom)
        self.set_comment(comment)
        self.set_add_route(add_route)
        self.set_keepalive(keepalive)
        self.set_add_gw_route(add_gw_route)
        self.set_net_device(net_device)
        self.set_tunnel_search(tunnel_search)
        self.set_dpd(dpd)
        self.set_dhgrp(dhgrp)
        self.set_nattraversal(nattraversal)
        self.set_exchange_interface_ip(exchange_interface_ip)


    def set_name(self, name):
        &#34;&#34;&#34; Set self.name to name if name is valid

        Args:
            name: Name of object

        Returns:
            None
        &#34;&#34;&#34;
        if name:
            if name.isspace(): raise Exception(&#34;\&#34;name\&#34;, cannot be an empty string&#34;)
            if isinstance(name, str):
                if len(name) &lt;= 35:
                    self.name = name
                else:
                    raise Exception(&#34;\&#34;name\&#34;, must be less than 35 chars or less&#34;)
            else:
                raise Exception(&#34;\&#34;name\&#34;, must be a string&#34;)
        else:
            raise Exception(&#34;Value \&#34;name\&#34; is required but was not provided&#34;)

    def set_proposal(self, proposal):
        &#34;&#34;&#34; Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals

        Args:
            proposal (list): string containing a single p1 proposal or list of strings with one or more p1 propolsals

        Returns:
            None
        &#34;&#34;&#34;
        valid_proposals = [&#39;des-md5&#39;, &#39;des-sha&#39;, &#39;des-sha256&#39;, &#39;des-sha384&#39;, &#39;des-sha512&#39;, &#39;3des-md5&#39;, &#39;3des-sha1&#39;,
                           &#39;3des-sha256&#39;, &#39;3des-sha384&#39;, &#39;3des-sha512&#39;, &#39;aes128-md5&#39;, &#39;aes128-sha1&#39;, &#39;aes128-sha256&#39;,
                           &#39;aes128-sha384&#39;, &#39;aes128-sha512&#39;, &#39;aes192-md5&#39;, &#39;aes192-sha1&#39;, &#39;aes192-sha256&#39;,
                           &#39;aes192-sha384&#39;, &#39;aes192-sha512&#39;, &#39;aes256-md5&#39;, &#39;aes256-sha1&#39;, &#39;aes256-sha256&#39;,
                           &#39;aes256-sha384&#39;, &#39;aes256-sha512&#39;, &#39;aria128-md5&#39;, &#39;aria128-sha1&#39;, &#39;aria128-sha256&#39;,
                           &#39;aria128-sha384&#39;, &#39;aria128-sha512&#39;, &#39;aria192-md5&#39;, &#39;aria192-sha1&#39;, &#39;aria192-sha256&#39;,
                           &#39;aria192-sha384&#39;, &#39;aria192-sha512&#39;, &#39;aria256-md5&#39;, &#39;aria256-sha1&#39;, &#39;aria256-sha256&#39;,
                           &#39;aria256-sha384&#39;, &#39;aria256-sha512&#39;, &#39;seed-md5&#39;, &#39;seed-sha1&#39;, &#39;seed-sha256&#39;, &#39;seed-sha384&#39;,
                           &#39;seed-sha512&#39;]

        if proposal:
            proposal_items = &#39;&#39;

            # IF a single object was passed as a string, append it to intf_list else iterate the list and pull
            # out the strings of interfaces and append each to intf_list
            if isinstance(proposal, str):

                # compare proposal to valid_proposals list
                if proposal in valid_proposals:
                    proposal_items += &#34;{} &#34;.format(proposal)
                else:
                    raise Exception(&#34;\&#34;proposal\&#34; provided: {} is not a valid fortigate phase1 proposal &#34;
                                    &#34;option&#34;.format(proposal))

            elif isinstance(proposal, list):
                for item in proposal:
                    if isinstance(item, str):

                        # compare proposal to valid proposals list
                        if item in valid_proposals:
                            proposal_items += &#34;{} &#34;.format(item)
                        else:
                            raise Exception(&#34;\&#34;proposal\&#34; provided: {} is not a valid fortigate phase1 proposal &#34;
                                            &#34;option&#34;.format(proposal))
            else:
                raise Exception(&#34;proposal must be provided as type string (with single proposal referenced or as a &#34;
                                &#34;list for multiple proposal references&#34;)

            self.proposal = proposal_items

        else:
            self.proposal = None

    def set_dhgrp(self, dhgrp):
        &#34;&#34;&#34; Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp

        The dhgrp may be passed in as a str, or a list.  If the dhgrp(s) passed in are valid, add each
        of those to a space separated values string and set in self.dhgrp

        Args:
            dhgrp (list): single int representing one dhgrp or a list of ints for one or more dhgrps

        Returns:
            None
        &#34;&#34;&#34;
        if dhgrp:
            dhgrp_items = &#39;&#39;
            valid_dhgrps = [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 27, 28, 30, 31, 32]

            # IF a single object was passed as a string, append it to list else iterate the list and pull
            # out the dhgrps and add to list to be set as self object
            if isinstance(dhgrp, int):
                # compare proposal to valid_list
                if dhgrp in valid_dhgrps:
                    dhgrp_items += &#34;{} &#34;.format(dhgrp)
                else:
                    raise Exception(&#34;\&#34;dhgrp\&#34; provided: \&#34;{}\&#34;, is not a valid fortigate dhgrp&#34;.format(dhgrp))

            elif isinstance(dhgrp, list):
                for item in dhgrp:
                    if isinstance(item, int):

                        # compare proposal to valid proposals list
                        if item in valid_dhgrps:
                            dhgrp_items += &#34;{} &#34;.format(item)
                        else:
                            raise Exception(&#34;At least one \&#34;dhgrp\&#34; provided: {} is not a valid fortigate phase1 &#34;
                                            &#34;proposal option&#34;.format(dhgrp))
            else:
                raise Exception(&#34;dhgrp must be provided as type integer&#34;)

            self.dhgrp = dhgrp_items

        else:
            self.dhgrp = None

    def set_p1_type(self, p1_type):
        &#34;&#34;&#34; Set self.pt_type to p1_type if p1_type is valid

        Args:
            p1_type (str): Phase1-interface type.  May be: &#39;dynamic&#39;, &#39;static&#39;, &#39;ddns&#39; or None=inherit

        Returns:

        &#34;&#34;&#34;
        if p1_type:
            if isinstance(p1_type, str):
                if p1_type.lower() == &#39;dynamic&#39;:
                    self.p1_type = &#39;dynamic&#39;
                elif p1_type.lower() == &#39;static&#39;:
                    self.p1_type = &#39;static&#39;
                elif p1_type.lower() == &#39;ddns&#39;:
                    raise Exception(&#34;p1_type of \&#34;ddns\&#34; is not yet supported&#34;)
                else:
                    raise Exception(&#34;\&#34;p1_type\&#34;: {} is not supported&#34;.format(p1_type))
            else:
                raise Exception(&#34;\&#34;p1_type\&#34; when set must be a str with value \&#34;dynamic\&#34; or \&#34;static\&#34;&#34;)
        else:
            self.p1_type = None

    def set_local_intf(self, intf):
        &#34;&#34;&#34; set self.local_intfs to intf if intfs is valid

        Args:
            intf (str): Local interface for p1 attachment

        Returns:
            None
        &#34;&#34;&#34;
        if intf:
            if intf.isspace(): raise Exception(&#34;\&#34;local_intf\&#34;, cannot be an empty string&#34;)
            if isinstance(intf, str):
                if len(intf) &lt; 35:
                    self.local_intf = intf
                else:
                    raise Exception(&#34;\&#34;local_intf\&#34;, must be less than 35 chars or less&#34;)
            else:
                raise Exception(&#34;\&#34;local_intf\&#34;, must be a string&#34;)
        else:
            raise Exception(&#34;\&#34;local_intf\&#34; not set, phase1 requires to define the interface&#34;)

    def set_ike_version(self, ike_version):
        &#34;&#34;&#34; Set self.ike_version to 1 or 2 if ike_version = 1 or 2.  Otherwise raise Exception

        Args:
            ike_version (int): ike-version.  May be 1 or 2.

        Returns:
            None
        &#34;&#34;&#34;
        if ike_version:
            if isinstance(ike_version, int):
                if ike_version == 1:
                    self.ike_version = 1
                elif ike_version == 2:
                    self.ike_version = 2
                else:
                    raise Exception(&#34;\&#34;ike_version\&#34;, when set must be type int with value = \&#34;1\&#34; or \&#34;2\&#34;&#34;)
            else:
                raise Exception(&#34;\&#34;ike_version\&#34; when set, must be type int with value = \&#34;1\&#34; or \&#34;2\&#34;&#34;)
        else:
            self.ike_version = None

    def set_local_gw(self, local_gw):
        &#34;&#34;&#34; Set self.local_gw to local_gw if local_gw is valid ipv4 address

        Args:
            local_gw (str): Local gateway.  Must be valid ipv4 address

        Returns:
            None
        &#34;&#34;&#34;
        if local_gw:
            try:
                ipaddress.ip_address(local_gw)
            except ValueError:
                print(&#34;\&#34;local_gw\&#34;, must be a valid ipv4 or ipv6 address&#34;)
            else:
                self.local_gw = local_gw
        else:
            self.local_gw = None

    def set_remote_gw(self, remote_gw):
        &#34;&#34;&#34; Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address

        Args:
            remote_gw (str): Address of remote vpn peer gateway.  Must be valid ipv4 address.

        Returns:
            None
        &#34;&#34;&#34;
        if remote_gw:
            try:
                ipaddress.ip_address(remote_gw)
            except ValueError:
                print(&#34;\&#34;remote_gw\&#34;, must be a valid ipv4 address&#34;)
            else:
                self.remote_gw = remote_gw
        else:
            if self.p1_type == &#39;dynamic&#39;:
                self.remote_gw = None
            else:
                raise Exception(&#34;\&#34;remote_gw\&#34; not set, static tunnel types require a remote gateway&#34;)

    def set_psk(self, psk):
        &#34;&#34;&#34; Set self.psk to psk if psk valid

        Args:
            psk (str): Phase1 psksecret.  Must be between 6 and 30 chars.

        Returns:
            None
        &#34;&#34;&#34;
        print(&#34;*** {} ***&#34;.format(psk))
        if psk:
            if isinstance(psk, str):
                if 6 &lt;= len(psk) &lt;= 30:
                    self.psk = psk
                else:
                    raise Exception(&#34;\&#34;psk\&#34;, must be an str between 6 and 30 chars&#34;)
            else:
                raise Exception(&#34;\&#34;psk\&#34;, must be a string&#34;)
        else:
            raise Exception(&#34;\&#34;psk\&#34; is required but was not provided&#34;)

    def set_local_id(self, local_id):
        &#34;&#34;&#34; Set self.local_id to local_id if local_id is valid

        Args:
            local_id (str): Phase1 local id

       Returns:
            None
        &#34;&#34;&#34;
        if local_id:
            if isinstance(local_id, str):
                if 1 &lt;= len(local_id) &lt;= 63:
                    self.local_id = local_id
                else:
                    raise Exception(&#34;\&#34;local_id\&#34;, when set, must be type str between 1 and 63 chars&#34;)
            else:
                raise Exception(&#34;\&#34;local_id\&#34;, when set, must be type str&#34;)
        else:
            self.local_id = None

    def set_comment(self, comment):
        &#34;&#34;&#34; Set self.comment to comment if comment is valid

        Args:
            comment (str): Phase1 comment

        Returns:
            None
        &#34;&#34;&#34;
        if comment:
            if isinstance(comment, str):
                if 1 &lt;= len(comment) &lt;= 1023:
                    self.comment = comment
                else:
                    raise Exception(&#34;\&#34;description\&#34;, when set, must be type str between 1 and 1,023 chars&#34;)
            else:
                raise Exception(&#34;\&#34;description\&#34;, when set, must be type str&#34;)
        else:
            self.comment = None

    def set_keepalive(self, keepalive):
        &#34;&#34;&#34; Set self.keepalive if keepalive valid

        Args:
            keepalive (int): phase1 keepalive

        Returns:
            None
        &#34;&#34;&#34;
        if keepalive:
            if isinstance(keepalive, int):
                if 10 &lt;= keepalive &lt;= 900:
                    self.keepalive = keepalive
                else:
                    raise Exception(&#34;\&#34;keepalive\&#34;, when set, must be type int between 10 and 900&#34;)
            else:
                raise Exception(&#34;\&#34;keepalive\&#34;, when set, must be type int&#34;)
        else:
            self.keepalive = None

    def set_add_route(self, add_route):
        &#34;&#34;&#34; Set self.add_route

        Args:
            add_route (bool): add-route. (True=enable, False=Disable, None=inherit)

        Returns:

        &#34;&#34;&#34;
        if isinstance(add_route, bool):
            self.add_route = &#39;enable&#39; if add_route else &#39;disable&#39;
        else:
            self.add_route = None

    def set_add_gw_route(self, add_gw_route):
        &#34;&#34;&#34; Set self.add_gw_route

        Args:
            add_gw_route (bool): add-gw-route.  (True=enable, False=Disable, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(add_gw_route, bool):
            self.add_gw_route = &#39;enable&#39; if add_gw_route else &#39;disable&#39;
        else:
            self.add_gw_route = None

    def set_net_device(self, net_device):
        &#34;&#34;&#34; set self.net_device

        Args:
            net_device (bool): net-device.  (True=enable, False=Disable, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(net_device, bool):
            self.net_device = &#39;enable&#39; if net_device else &#39;disable&#39;
        else:
            self.net_device = None

    def set_tunnel_search(self, tunnel_search):
        &#34;&#34;&#34; Set self.tunnel_search

        Args:
            tunnel_search (str): tunnel-search.  (&#39;selectors&#39;, &#39;nexthop&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(tunnel_search, str):
            if tunnel_search.lower() == &#39;selectors&#39;:
                self.tunnel_search = &#39;selectors&#39;
            elif tunnel_search.lower() == &#39;nexthop&#39;:
                self.tunnel_search = &#39;nexthop&#39;
            else:
                raise Exception(&#34;\&#34;tunnel_search\&#34; was specified but is not value \&#34;selectors\&#34; or &#34;
                                &#34;\&#34;nexthop\&#34; as requried&#34;)
        else:
            self.tunnel_search = None

    def set_dpd(self, dpd):
        &#34;&#34;&#34; Set self.dpd

        Args:
            dpd (str): phase1 dpd.   (&#39;disable&#39;, &#39;on-idle&#39;, &#39;on-demand&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(dpd, str):
            if dpd.lower() == &#39;disable&#39;:
                self.dpd = &#39;disable&#39;
            elif dpd.lower() == &#39;on-idle&#39;:
                self.dpd = &#39;on-idle&#39;
            elif dpd.lower == &#39;on-demand&#39;:
                self.dpd = &#39;on-demand&#39;
            else:
                raise Exception(&#34;\&#34;dpd\&#34; was specied but is not value \&#34;disable\&#34;, \&#34;on-idle\&#34; or \&#34;on-demmand\&#34;&#34;
                                &#34;as required&#34;)
        else:
            self.dpd = None

    def set_nattraversal(self, nattraversal):
        &#34;&#34;&#34; Set self.nat_traversal

        Args:
            nattraversal (str): nat-traversal.  (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(nattraversal, str):
            if nattraversal.lower() == &#39;enable&#39;:
                self.nattraversal = &#39;enable&#39;
            elif nattraversal.lower() == &#39;disable&#39;:
                self.nattraversal = &#39;disable&#39;
            elif nattraversal.lower() == &#39;forced&#39;:
                self.nattraversal = &#39;forced&#39;
            else:
                raise Exception(&#34;\&#34;nattraversal\&#34; when set, must be a string value of \&#34;enable\&#34;, &#34;
                                &#34;\&#34;disable\&#34; or \&#34;forced\&#34;&#34;)
        else:
            self.nattraversal = None

    def set_exchange_interface_ip(self, exchange_interface_ip):
        &#34;&#34;&#34; Set self.exchange_interface_ip

        Args:
            exchange_interface_ip (bool): exchange-interface-ip. (True=enable, False=Disable, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if isinstance(exchange_interface_ip, bool):
            self.exchange_interface_ip = &#39;enable&#39; if exchange_interface_ip else &#39;disable&#39;
        else:
            self.exchange_interface_ip = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fgobjlib.fg_object.FgObject" href="fg_object.html#fgobjlib.fg_object.FgObject">FgObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_gw_route"><code class="name flex">
<span>def <span class="ident">set_add_gw_route</span></span>(<span>self, add_gw_route)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.add_gw_route</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>add_gw_route</code></strong> :&ensp;<code>bool</code></dt>
<dd>add-gw-route.
(True=enable, False=Disable, None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_add_gw_route(self, add_gw_route):
    &#34;&#34;&#34; Set self.add_gw_route

    Args:
        add_gw_route (bool): add-gw-route.  (True=enable, False=Disable, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if isinstance(add_gw_route, bool):
        self.add_gw_route = &#39;enable&#39; if add_gw_route else &#39;disable&#39;
    else:
        self.add_gw_route = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_route"><code class="name flex">
<span>def <span class="ident">set_add_route</span></span>(<span>self, add_route)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.add_route</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>add_route</code></strong> :&ensp;<code>bool</code></dt>
<dd>add-route. (True=enable, False=Disable, None=inherit)</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_add_route(self, add_route):
    &#34;&#34;&#34; Set self.add_route

    Args:
        add_route (bool): add-route. (True=enable, False=Disable, None=inherit)

    Returns:

    &#34;&#34;&#34;
    if isinstance(add_route, bool):
        self.add_route = &#39;enable&#39; if add_route else &#39;disable&#39;
    else:
        self.add_route = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_comment"><code class="name flex">
<span>def <span class="ident">set_comment</span></span>(<span>self, comment)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.comment to comment if comment is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1 comment</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_comment(self, comment):
    &#34;&#34;&#34; Set self.comment to comment if comment is valid

    Args:
        comment (str): Phase1 comment

    Returns:
        None
    &#34;&#34;&#34;
    if comment:
        if isinstance(comment, str):
            if 1 &lt;= len(comment) &lt;= 1023:
                self.comment = comment
            else:
                raise Exception(&#34;\&#34;description\&#34;, when set, must be type str between 1 and 1,023 chars&#34;)
        else:
            raise Exception(&#34;\&#34;description\&#34;, when set, must be type str&#34;)
    else:
        self.comment = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dhgrp"><code class="name flex">
<span>def <span class="ident">set_dhgrp</span></span>(<span>self, dhgrp)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp</p>
<p>The dhgrp may be passed in as a str, or a list.
If the dhgrp(s) passed in are valid, add each
of those to a space separated values string and set in self.dhgrp</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dhgrp</code></strong> :&ensp;<code>list</code></dt>
<dd>single int representing one dhgrp or a list of ints for one or more dhgrps</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dhgrp(self, dhgrp):
    &#34;&#34;&#34; Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp

    The dhgrp may be passed in as a str, or a list.  If the dhgrp(s) passed in are valid, add each
    of those to a space separated values string and set in self.dhgrp

    Args:
        dhgrp (list): single int representing one dhgrp or a list of ints for one or more dhgrps

    Returns:
        None
    &#34;&#34;&#34;
    if dhgrp:
        dhgrp_items = &#39;&#39;
        valid_dhgrps = [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 27, 28, 30, 31, 32]

        # IF a single object was passed as a string, append it to list else iterate the list and pull
        # out the dhgrps and add to list to be set as self object
        if isinstance(dhgrp, int):
            # compare proposal to valid_list
            if dhgrp in valid_dhgrps:
                dhgrp_items += &#34;{} &#34;.format(dhgrp)
            else:
                raise Exception(&#34;\&#34;dhgrp\&#34; provided: \&#34;{}\&#34;, is not a valid fortigate dhgrp&#34;.format(dhgrp))

        elif isinstance(dhgrp, list):
            for item in dhgrp:
                if isinstance(item, int):

                    # compare proposal to valid proposals list
                    if item in valid_dhgrps:
                        dhgrp_items += &#34;{} &#34;.format(item)
                    else:
                        raise Exception(&#34;At least one \&#34;dhgrp\&#34; provided: {} is not a valid fortigate phase1 &#34;
                                        &#34;proposal option&#34;.format(dhgrp))
        else:
            raise Exception(&#34;dhgrp must be provided as type integer&#34;)

        self.dhgrp = dhgrp_items

    else:
        self.dhgrp = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dpd"><code class="name flex">
<span>def <span class="ident">set_dpd</span></span>(<span>self, dpd)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.dpd</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dpd</code></strong> :&ensp;<code>str</code></dt>
<dd>phase1 dpd.
('disable', 'on-idle', 'on-demand', None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dpd(self, dpd):
    &#34;&#34;&#34; Set self.dpd

    Args:
        dpd (str): phase1 dpd.   (&#39;disable&#39;, &#39;on-idle&#39;, &#39;on-demand&#39;, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if isinstance(dpd, str):
        if dpd.lower() == &#39;disable&#39;:
            self.dpd = &#39;disable&#39;
        elif dpd.lower() == &#39;on-idle&#39;:
            self.dpd = &#39;on-idle&#39;
        elif dpd.lower == &#39;on-demand&#39;:
            self.dpd = &#39;on-demand&#39;
        else:
            raise Exception(&#34;\&#34;dpd\&#34; was specied but is not value \&#34;disable\&#34;, \&#34;on-idle\&#34; or \&#34;on-demmand\&#34;&#34;
                            &#34;as required&#34;)
    else:
        self.dpd = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_exchange_interface_ip"><code class="name flex">
<span>def <span class="ident">set_exchange_interface_ip</span></span>(<span>self, exchange_interface_ip)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.exchange_interface_ip</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exchange_interface_ip</code></strong> :&ensp;<code>bool</code></dt>
<dd>exchange-interface-ip. (True=enable, False=Disable, None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_exchange_interface_ip(self, exchange_interface_ip):
    &#34;&#34;&#34; Set self.exchange_interface_ip

    Args:
        exchange_interface_ip (bool): exchange-interface-ip. (True=enable, False=Disable, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if isinstance(exchange_interface_ip, bool):
        self.exchange_interface_ip = &#39;enable&#39; if exchange_interface_ip else &#39;disable&#39;
    else:
        self.exchange_interface_ip = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_ike_version"><code class="name flex">
<span>def <span class="ident">set_ike_version</span></span>(<span>self, ike_version)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.ike_version to 1 or 2 if ike_version = 1 or 2.
Otherwise raise Exception</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ike_version</code></strong> :&ensp;<code>int</code></dt>
<dd>ike-version.
May be 1 or 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ike_version(self, ike_version):
    &#34;&#34;&#34; Set self.ike_version to 1 or 2 if ike_version = 1 or 2.  Otherwise raise Exception

    Args:
        ike_version (int): ike-version.  May be 1 or 2.

    Returns:
        None
    &#34;&#34;&#34;
    if ike_version:
        if isinstance(ike_version, int):
            if ike_version == 1:
                self.ike_version = 1
            elif ike_version == 2:
                self.ike_version = 2
            else:
                raise Exception(&#34;\&#34;ike_version\&#34;, when set must be type int with value = \&#34;1\&#34; or \&#34;2\&#34;&#34;)
        else:
            raise Exception(&#34;\&#34;ike_version\&#34; when set, must be type int with value = \&#34;1\&#34; or \&#34;2\&#34;&#34;)
    else:
        self.ike_version = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_keepalive"><code class="name flex">
<span>def <span class="ident">set_keepalive</span></span>(<span>self, keepalive)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.keepalive if keepalive valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keepalive</code></strong> :&ensp;<code>int</code></dt>
<dd>phase1 keepalive</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_keepalive(self, keepalive):
    &#34;&#34;&#34; Set self.keepalive if keepalive valid

    Args:
        keepalive (int): phase1 keepalive

    Returns:
        None
    &#34;&#34;&#34;
    if keepalive:
        if isinstance(keepalive, int):
            if 10 &lt;= keepalive &lt;= 900:
                self.keepalive = keepalive
            else:
                raise Exception(&#34;\&#34;keepalive\&#34;, when set, must be type int between 10 and 900&#34;)
        else:
            raise Exception(&#34;\&#34;keepalive\&#34;, when set, must be type int&#34;)
    else:
        self.keepalive = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_gw"><code class="name flex">
<span>def <span class="ident">set_local_gw</span></span>(<span>self, local_gw)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.local_gw to local_gw if local_gw is valid ipv4 address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Local gateway.
Must be valid ipv4 address</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_local_gw(self, local_gw):
    &#34;&#34;&#34; Set self.local_gw to local_gw if local_gw is valid ipv4 address

    Args:
        local_gw (str): Local gateway.  Must be valid ipv4 address

    Returns:
        None
    &#34;&#34;&#34;
    if local_gw:
        try:
            ipaddress.ip_address(local_gw)
        except ValueError:
            print(&#34;\&#34;local_gw\&#34;, must be a valid ipv4 or ipv6 address&#34;)
        else:
            self.local_gw = local_gw
    else:
        self.local_gw = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_id"><code class="name flex">
<span>def <span class="ident">set_local_id</span></span>(<span>self, local_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.local_id to local_id if local_id is valid</p>
<p>Args:
local_id (str): Phase1 local id</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_local_id(self, local_id):
    &#34;&#34;&#34; Set self.local_id to local_id if local_id is valid

    Args:
        local_id (str): Phase1 local id

   Returns:
        None
    &#34;&#34;&#34;
    if local_id:
        if isinstance(local_id, str):
            if 1 &lt;= len(local_id) &lt;= 63:
                self.local_id = local_id
            else:
                raise Exception(&#34;\&#34;local_id\&#34;, when set, must be type str between 1 and 63 chars&#34;)
        else:
            raise Exception(&#34;\&#34;local_id\&#34;, when set, must be type str&#34;)
    else:
        self.local_id = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_intf"><code class="name flex">
<span>def <span class="ident">set_local_intf</span></span>(<span>self, intf)</span>
</code></dt>
<dd>
<section class="desc"><p>set self.local_intfs to intf if intfs is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>intf</code></strong> :&ensp;<code>str</code></dt>
<dd>Local interface for p1 attachment</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_local_intf(self, intf):
    &#34;&#34;&#34; set self.local_intfs to intf if intfs is valid

    Args:
        intf (str): Local interface for p1 attachment

    Returns:
        None
    &#34;&#34;&#34;
    if intf:
        if intf.isspace(): raise Exception(&#34;\&#34;local_intf\&#34;, cannot be an empty string&#34;)
        if isinstance(intf, str):
            if len(intf) &lt; 35:
                self.local_intf = intf
            else:
                raise Exception(&#34;\&#34;local_intf\&#34;, must be less than 35 chars or less&#34;)
        else:
            raise Exception(&#34;\&#34;local_intf\&#34;, must be a string&#34;)
    else:
        raise Exception(&#34;\&#34;local_intf\&#34; not set, phase1 requires to define the interface&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.name to name if name is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    &#34;&#34;&#34; Set self.name to name if name is valid

    Args:
        name: Name of object

    Returns:
        None
    &#34;&#34;&#34;
    if name:
        if name.isspace(): raise Exception(&#34;\&#34;name\&#34;, cannot be an empty string&#34;)
        if isinstance(name, str):
            if len(name) &lt;= 35:
                self.name = name
            else:
                raise Exception(&#34;\&#34;name\&#34;, must be less than 35 chars or less&#34;)
        else:
            raise Exception(&#34;\&#34;name\&#34;, must be a string&#34;)
    else:
        raise Exception(&#34;Value \&#34;name\&#34; is required but was not provided&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_nattraversal"><code class="name flex">
<span>def <span class="ident">set_nattraversal</span></span>(<span>self, nattraversal)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.nat_traversal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nattraversal</code></strong> :&ensp;<code>str</code></dt>
<dd>nat-traversal.
('enable', 'disable', 'forced', None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nattraversal(self, nattraversal):
    &#34;&#34;&#34; Set self.nat_traversal

    Args:
        nattraversal (str): nat-traversal.  (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39;, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if isinstance(nattraversal, str):
        if nattraversal.lower() == &#39;enable&#39;:
            self.nattraversal = &#39;enable&#39;
        elif nattraversal.lower() == &#39;disable&#39;:
            self.nattraversal = &#39;disable&#39;
        elif nattraversal.lower() == &#39;forced&#39;:
            self.nattraversal = &#39;forced&#39;
        else:
            raise Exception(&#34;\&#34;nattraversal\&#34; when set, must be a string value of \&#34;enable\&#34;, &#34;
                            &#34;\&#34;disable\&#34; or \&#34;forced\&#34;&#34;)
    else:
        self.nattraversal = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_net_device"><code class="name flex">
<span>def <span class="ident">set_net_device</span></span>(<span>self, net_device)</span>
</code></dt>
<dd>
<section class="desc"><p>set self.net_device</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>net_device</code></strong> :&ensp;<code>bool</code></dt>
<dd>net-device.
(True=enable, False=Disable, None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_net_device(self, net_device):
    &#34;&#34;&#34; set self.net_device

    Args:
        net_device (bool): net-device.  (True=enable, False=Disable, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if isinstance(net_device, bool):
        self.net_device = &#39;enable&#39; if net_device else &#39;disable&#39;
    else:
        self.net_device = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_p1_type"><code class="name flex">
<span>def <span class="ident">set_p1_type</span></span>(<span>self, p1_type)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.pt_type to p1_type if p1_type is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p1_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1-interface type.
May be: 'dynamic', 'static', 'ddns' or None=inherit</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_p1_type(self, p1_type):
    &#34;&#34;&#34; Set self.pt_type to p1_type if p1_type is valid

    Args:
        p1_type (str): Phase1-interface type.  May be: &#39;dynamic&#39;, &#39;static&#39;, &#39;ddns&#39; or None=inherit

    Returns:

    &#34;&#34;&#34;
    if p1_type:
        if isinstance(p1_type, str):
            if p1_type.lower() == &#39;dynamic&#39;:
                self.p1_type = &#39;dynamic&#39;
            elif p1_type.lower() == &#39;static&#39;:
                self.p1_type = &#39;static&#39;
            elif p1_type.lower() == &#39;ddns&#39;:
                raise Exception(&#34;p1_type of \&#34;ddns\&#34; is not yet supported&#34;)
            else:
                raise Exception(&#34;\&#34;p1_type\&#34;: {} is not supported&#34;.format(p1_type))
        else:
            raise Exception(&#34;\&#34;p1_type\&#34; when set must be a str with value \&#34;dynamic\&#34; or \&#34;static\&#34;&#34;)
    else:
        self.p1_type = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_proposal"><code class="name flex">
<span>def <span class="ident">set_proposal</span></span>(<span>self, proposal)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal</code></strong> :&ensp;<code>list</code></dt>
<dd>string containing a single p1 proposal or list of strings with one or more p1 propolsals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_proposal(self, proposal):
    &#34;&#34;&#34; Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals

    Args:
        proposal (list): string containing a single p1 proposal or list of strings with one or more p1 propolsals

    Returns:
        None
    &#34;&#34;&#34;
    valid_proposals = [&#39;des-md5&#39;, &#39;des-sha&#39;, &#39;des-sha256&#39;, &#39;des-sha384&#39;, &#39;des-sha512&#39;, &#39;3des-md5&#39;, &#39;3des-sha1&#39;,
                       &#39;3des-sha256&#39;, &#39;3des-sha384&#39;, &#39;3des-sha512&#39;, &#39;aes128-md5&#39;, &#39;aes128-sha1&#39;, &#39;aes128-sha256&#39;,
                       &#39;aes128-sha384&#39;, &#39;aes128-sha512&#39;, &#39;aes192-md5&#39;, &#39;aes192-sha1&#39;, &#39;aes192-sha256&#39;,
                       &#39;aes192-sha384&#39;, &#39;aes192-sha512&#39;, &#39;aes256-md5&#39;, &#39;aes256-sha1&#39;, &#39;aes256-sha256&#39;,
                       &#39;aes256-sha384&#39;, &#39;aes256-sha512&#39;, &#39;aria128-md5&#39;, &#39;aria128-sha1&#39;, &#39;aria128-sha256&#39;,
                       &#39;aria128-sha384&#39;, &#39;aria128-sha512&#39;, &#39;aria192-md5&#39;, &#39;aria192-sha1&#39;, &#39;aria192-sha256&#39;,
                       &#39;aria192-sha384&#39;, &#39;aria192-sha512&#39;, &#39;aria256-md5&#39;, &#39;aria256-sha1&#39;, &#39;aria256-sha256&#39;,
                       &#39;aria256-sha384&#39;, &#39;aria256-sha512&#39;, &#39;seed-md5&#39;, &#39;seed-sha1&#39;, &#39;seed-sha256&#39;, &#39;seed-sha384&#39;,
                       &#39;seed-sha512&#39;]

    if proposal:
        proposal_items = &#39;&#39;

        # IF a single object was passed as a string, append it to intf_list else iterate the list and pull
        # out the strings of interfaces and append each to intf_list
        if isinstance(proposal, str):

            # compare proposal to valid_proposals list
            if proposal in valid_proposals:
                proposal_items += &#34;{} &#34;.format(proposal)
            else:
                raise Exception(&#34;\&#34;proposal\&#34; provided: {} is not a valid fortigate phase1 proposal &#34;
                                &#34;option&#34;.format(proposal))

        elif isinstance(proposal, list):
            for item in proposal:
                if isinstance(item, str):

                    # compare proposal to valid proposals list
                    if item in valid_proposals:
                        proposal_items += &#34;{} &#34;.format(item)
                    else:
                        raise Exception(&#34;\&#34;proposal\&#34; provided: {} is not a valid fortigate phase1 proposal &#34;
                                        &#34;option&#34;.format(proposal))
        else:
            raise Exception(&#34;proposal must be provided as type string (with single proposal referenced or as a &#34;
                            &#34;list for multiple proposal references&#34;)

        self.proposal = proposal_items

    else:
        self.proposal = None</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_psk"><code class="name flex">
<span>def <span class="ident">set_psk</span></span>(<span>self, psk)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.psk to psk if psk valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>psk</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1 psksecret.
Must be between 6 and 30 chars.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_psk(self, psk):
    &#34;&#34;&#34; Set self.psk to psk if psk valid

    Args:
        psk (str): Phase1 psksecret.  Must be between 6 and 30 chars.

    Returns:
        None
    &#34;&#34;&#34;
    print(&#34;*** {} ***&#34;.format(psk))
    if psk:
        if isinstance(psk, str):
            if 6 &lt;= len(psk) &lt;= 30:
                self.psk = psk
            else:
                raise Exception(&#34;\&#34;psk\&#34;, must be an str between 6 and 30 chars&#34;)
        else:
            raise Exception(&#34;\&#34;psk\&#34;, must be a string&#34;)
    else:
        raise Exception(&#34;\&#34;psk\&#34; is required but was not provided&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_remote_gw"><code class="name flex">
<span>def <span class="ident">set_remote_gw</span></span>(<span>self, remote_gw)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>remote_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Address of remote vpn peer gateway.
Must be valid ipv4 address.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_remote_gw(self, remote_gw):
    &#34;&#34;&#34; Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address

    Args:
        remote_gw (str): Address of remote vpn peer gateway.  Must be valid ipv4 address.

    Returns:
        None
    &#34;&#34;&#34;
    if remote_gw:
        try:
            ipaddress.ip_address(remote_gw)
        except ValueError:
            print(&#34;\&#34;remote_gw\&#34;, must be a valid ipv4 address&#34;)
        else:
            self.remote_gw = remote_gw
    else:
        if self.p1_type == &#39;dynamic&#39;:
            self.remote_gw = None
        else:
            raise Exception(&#34;\&#34;remote_gw\&#34; not set, static tunnel types require a remote gateway&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_tunnel_search"><code class="name flex">
<span>def <span class="ident">set_tunnel_search</span></span>(<span>self, tunnel_search)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.tunnel_search</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tunnel_search</code></strong> :&ensp;<code>str</code></dt>
<dd>tunnel-search.
('selectors', 'nexthop', None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tunnel_search(self, tunnel_search):
    &#34;&#34;&#34; Set self.tunnel_search

    Args:
        tunnel_search (str): tunnel-search.  (&#39;selectors&#39;, &#39;nexthop&#39;, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if isinstance(tunnel_search, str):
        if tunnel_search.lower() == &#39;selectors&#39;:
            self.tunnel_search = &#39;selectors&#39;
        elif tunnel_search.lower() == &#39;nexthop&#39;:
            self.tunnel_search = &#39;nexthop&#39;
        else:
            raise Exception(&#34;\&#34;tunnel_search\&#34; was specified but is not value \&#34;selectors\&#34; or &#34;
                            &#34;\&#34;nexthop\&#34; as requried&#34;)
    else:
        self.tunnel_search = None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fgobjlib.fg_object.FgObject" href="fg_object.html#fgobjlib.fg_object.FgObject">FgObject</a></b></code>:
<ul class="hlist">
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_add" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_add">get_api_config_add</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_del" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_del">get_api_config_del</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_get" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_get">get_api_config_get</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_update" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_update">get_api_config_update</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_cli_config_add" href="fg_object.html#fgobjlib.fg_object.FgObject.get_cli_config_add">get_cli_config_add</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_cli_config_del" href="fg_object.html#fgobjlib.fg_object.FgObject.get_cli_config_del">get_cli_config_del</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_cli_config_update" href="fg_object.html#fgobjlib.fg_object.FgObject.get_cli_config_update">get_cli_config_update</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.set_vdom" href="fg_object.html#fgobjlib.fg_object.FgObject.set_vdom">set_vdom</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fgobjlib" href="index.html">fgobjlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface">FgIpsecP1Interface</a></code></h4>
<ul class="">
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_gw_route" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_gw_route">set_add_gw_route</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_route" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_route">set_add_route</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_comment" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_comment">set_comment</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dhgrp" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dhgrp">set_dhgrp</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dpd" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dpd">set_dpd</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_exchange_interface_ip" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_exchange_interface_ip">set_exchange_interface_ip</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_ike_version" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_ike_version">set_ike_version</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_keepalive" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_keepalive">set_keepalive</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_gw" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_gw">set_local_gw</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_id" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_id">set_local_id</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_intf" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_intf">set_local_intf</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_name" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_name">set_name</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_nattraversal" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_nattraversal">set_nattraversal</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_net_device" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_net_device">set_net_device</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_p1_type" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_p1_type">set_p1_type</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_proposal" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_proposal">set_proposal</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_psk" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_psk">set_psk</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_remote_gw" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_remote_gw">set_remote_gw</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_tunnel_search" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_tunnel_search">set_tunnel_search</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>