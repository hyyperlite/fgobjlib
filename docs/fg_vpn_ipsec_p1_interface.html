<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>fgobjlib.fg_vpn_ipsec_p1_interface API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fgobjlib.fg_vpn_ipsec_p1_interface</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from fgobjlib import FgObject
import ipaddress

class FgIpsecP1Interface(FgObject):
    &#34;&#34;&#34; FgIpsecP1Interface class represents FortiGate Firewall ipsec phase1 interface object and provides methods for
    validating parameters and generating both cli and api configuration data for use in external configuration
    applications

    Currently supports dynamic or static VPN using psk authentication. No support yet for advpn or mode-cfg

    Attributes:
        name (str): Name of ipsec phase1-interface object
        p1_type (str): Phase1-interface type
        interface (str): Name of locally attached fortigate interface
        proposal (list): Phase1-interface proposal(s)
        ike_version (int): ike version
        local_gw (str): Phase1-interface local-gw IP
        psksecret (str): Pre-shared key
        localid (str): Local ID
        remote_gw (str): Remote Gateway
        add_route (str):  add-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        add_gw_route (str): add-gw-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        keepalive (int): Keepalive in seconds
        net_device (str): net-device  (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        comment (str): phase1 comment
        vdom (str): Associated VDOM, if applicable
        tunnel_search (str):  tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
        dpd (str): phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
        dhgrp (str): dhgrp
        nattraversal (str): nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
        exchange_interface_ip (str): exchange-interface-ip (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
    &#34;&#34;&#34;

    def __init__(self, name: str = None, p1_type: str = None, interface: str = None, proposal: list = None,
                 ike_version: int = None, local_gw: str = None, psksecret: str = None, localid: str = None,
                 remote_gw: str = None, add_route: str = None, add_gw_route: str = None, keepalive: int = None,
                 net_device: str = None, comment: str = None, vdom: str = None, tunnel_search: str = None,
                 dpd: str = None, dhgrp: list = None, nattraversal: str = None, exchange_interface_ip: str = None):

        &#34;&#34;&#34;
        Args:
            name (str): Set name of ipsec phase1-interface object
            p1_type (str): Set phase1-interface type
            interface (str): Set name of locally attached fortigate interface
            proposal (list): Set phase1-interface proposal(s)
            ike_version (int): Set ike version
            local_gw (str): Set phase1-interface local-gw IP
            psksecret (str): Set pre-shared key
            localid (str): Set local ID
            remote_gw (str): Set remote Gateway
            add_route (str):  Set add-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
            add_gw_route (str): Set add-gw-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
            keepalive (int): Set keepalive in seconds
            net_device (str): Set net-device (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
            comment (str): Set phase1 comment
            vdom (str): Set associated VDOM, if applicable
            tunnel_search (str):  Set tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
            dpd (list): Set phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
            nattraversal (str): Set nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
            exchange_interface_ip (str): Set exchange-interfce-ip (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        &#34;&#34;&#34;

        # Initialize the parent class
        super().__init__(api=&#39;cmdb&#39;, api_path=&#39;vpn.ipsec&#39;, api_name=&#39;phase1-interface&#39;,
                         cli_path=&#34;config vpn ipsec phase1-interface&#34;, obj_id=name, vdom=vdom)

        ### Set parent class attributes ###
        # CLI config path for this object type
        self.cli_path = &#34;config vpn ipsec phase1-interface&#34;

        # Map instance attribute names to fg attribute names
        self.data_attrs = {&#39;name&#39;: &#39;name&#39;, &#39;p1_type&#39;: &#39;type&#39;, &#39;interface&#39;: &#39;interface&#39;, &#39;proposal&#39;: &#39;proposal&#39;,
                           &#39;ike_version&#39;: &#39;ike-version&#39;, &#39;local_gw&#39;: &#39;local-gw&#39;, &#39;psksecret&#39;: &#39;psksecret&#39;,
                           &#39;localid&#39;: &#39;localid&#39;, &#39;remote_gw&#39;: &#39;remote-gw&#39;, &#39;comment&#39;: &#39;comments&#39;,
                           &#39;add_route&#39;: &#39;add-route&#39;, &#39;add_gw_route&#39;: &#39;add-gw-route&#39;, &#39;keepalive&#39;: &#39;keepalive&#39;,
                           &#39;net_device&#39;: &#39;net-device&#39;, &#39;tunnel_search&#39;: &#39;tunnel-search&#39;, &#39;dpd&#39;: &#39;dpd&#39;, &#39;dhgrp&#39;: &#39;dhgrp&#39;,
                           &#39;nattraversal&#39;: &#39;nattraversal&#39;, &#39;exchange_interface_ip&#39;: &#39;exchange-interface-ip&#39;}

        self.cli_ignore_attrs = [&#39;name&#39;]

        # Set instance attributes
        self.set_name(name)
        self.set_p1_type(p1_type)
        self.set_interface(interface)
        self.set_proposal(proposal)
        self.set_ike_version(ike_version)
        self.set_local_gw(local_gw)
        self.set_psksecret(psksecret)
        self.set_localid(localid)
        self.set_remote_gw(remote_gw)
        self.set_comment(comment)
        self.set_add_route(add_route)
        self.set_keepalive(keepalive)
        self.set_add_gw_route(add_gw_route)
        self.set_net_device(net_device)
        self.set_tunnel_search(tunnel_search)
        self.set_dpd(dpd)
        self.set_dhgrp(dhgrp)
        self.set_nattraversal(nattraversal)
        self.set_exchange_interface_ip(exchange_interface_ip)

        self.obj_to_str += f&#39;, name={name}, p1_type={p1_type}, interface={self.interface}, &#39; \
                          f&#39;proposal={self.proposal}, ike_version={self.ike_version}, local_gw={self.local_gw}, &#39; \
                          f&#39;psksecret={self.psksecret}, localid={self.localid}, remote_gw={self.remote_gw}, &#39; \
                          f&#39;comment={self.comment}, add_route={self.add_route}, add_gw_route={self.add_gw_route}, &#39; \
                          f&#39;keepalive={self.keepalive}, net_device={self.net_device}, &#39; \
                          f&#39;tunnel_search={self.tunnel_search}, dpd={self.dpd}, dhgrp={self.dhgrp},&#39; \
                          f&#39;nattraversal={self.nattraversal}, exchange_interface_ip={self.exchange_interface_ip}&#39;


    # Instance Methods
    def set_name(self, name):
        &#34;&#34;&#34; Set self.name to name if name is valid

        Args:
            name: Name of object

        Returns:
            None
        &#34;&#34;&#34;
        if name is None:
            self.name = None

        else:
            if name.isspace(): raise Exception(&#34;&#39;name&#39;, cannot be an empty string&#34;)
            if isinstance(name, str):
                if len(name) &lt;= 35:
                    self.name = name
                else:
                    raise Exception(&#34;&#39;name&#39;, must be less than 35 chars or less&#34;)
            else:
                raise Exception(&#34;&#39;name&#39;, must be a string&#34;)

    def set_proposal(self, proposal):
        &#34;&#34;&#34; Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals

        Args:
            proposal (list): string containing a single p1 proposal or list of strings with one or more p1 propolsals

        Returns:
            None
        &#34;&#34;&#34;
        valid_proposals = [&#39;des-md5&#39;, &#39;des-sha&#39;, &#39;des-sha256&#39;, &#39;des-sha384&#39;, &#39;des-sha512&#39;, &#39;3des-md5&#39;, &#39;3des-sha1&#39;,
                           &#39;3des-sha256&#39;, &#39;3des-sha384&#39;, &#39;3des-sha512&#39;, &#39;aes128-md5&#39;, &#39;aes128-sha1&#39;, &#39;aes128-sha256&#39;,
                           &#39;aes128-sha384&#39;, &#39;aes128-sha512&#39;, &#39;aes192-md5&#39;, &#39;aes192-sha1&#39;, &#39;aes192-sha256&#39;,
                           &#39;aes192-sha384&#39;, &#39;aes192-sha512&#39;, &#39;aes256-md5&#39;, &#39;aes256-sha1&#39;, &#39;aes256-sha256&#39;,
                           &#39;aes256-sha384&#39;, &#39;aes256-sha512&#39;, &#39;aria128-md5&#39;, &#39;aria128-sha1&#39;, &#39;aria128-sha256&#39;,
                           &#39;aria128-sha384&#39;, &#39;aria128-sha512&#39;, &#39;aria192-md5&#39;, &#39;aria192-sha1&#39;, &#39;aria192-sha256&#39;,
                           &#39;aria192-sha384&#39;, &#39;aria192-sha512&#39;, &#39;aria256-md5&#39;, &#39;aria256-sha1&#39;, &#39;aria256-sha256&#39;,
                           &#39;aria256-sha384&#39;, &#39;aria256-sha512&#39;, &#39;seed-md5&#39;, &#39;seed-sha1&#39;, &#39;seed-sha256&#39;, &#39;seed-sha384&#39;,
                           &#39;seed-sha512&#39;]

        if proposal is None:
            self.proposal = None

        else:
            proposal_items = &#39;&#39;

            # IF a single object was passed as a string, append it to intf_list else iterate the list and pull
            # out the strings of interfaces and append each to intf_list
            if isinstance(proposal, str):

                # compare proposal to valid_proposals list
                if proposal in valid_proposals:
                    proposal_items += f&#34;{proposal} &#34;
                else:
                    raise ValueError(f&#34;&#39;proposal&#39; provided: {proposal} is not a valid FortiGate phase1 proposal&#34;)

            elif isinstance(proposal, list):
                for item in proposal:
                    if isinstance(item, str):

                        # compare proposal to valid proposals list
                        if item in valid_proposals:
                            proposal_items += f&#34;{item} &#34;
                        else:
                            raise ValueError(&#34;&#39;proposal&#39; provided: {proposal} is not a valid FortiGate phase1 proposal&#34;)
            else:
                raise ValueError(&#34;proposal must be provided as type string (with single proposal referenced or as a &#34;
                                 &#34;list for multiple proposal references&#34;)

            self.proposal = proposal_items

    def set_dhgrp(self, dhgrp):
        &#34;&#34;&#34; Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp

        The dhgrp may be passed in as a str, or a list.  If the dhgrp(s) passed in are valid, add each
        of those to a space separated values string and set in self.dhgrp

        Args:
            dhgrp (list): single int representing one dhgrp or a list of ints for one or more dhgrps

        Returns:
            None
        &#34;&#34;&#34;
        if dhgrp is None:
            self.dhgrp = None

        else:
            dhgrp_items = &#39;&#39;
            valid_dhgrps = [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 27, 28, 30, 31, 32]

            # IF a single object was passed as a string, append it to list else iterate the list and pull
            # out the dhgrps and add to list to be set as self object
            if isinstance(dhgrp, int):
                # compare proposal to valid_list
                if dhgrp in valid_dhgrps:
                    dhgrp_items += &#34;{} &#34;.format(dhgrp)
                else:
                    raise ValueError(f&#34;&#39;dhgrp&#39; provided: {dhgrp}, is not a valid fortigate dhgrp&#34;)

            elif isinstance(dhgrp, list):
                for item in dhgrp:
                    if isinstance(item, int):

                        # compare proposal to valid proposals list
                        if item in valid_dhgrps:
                            dhgrp_items += &#34;{} &#34;.format(item)
                        else:
                            raise ValueError(f&#34;At least one &#39;dhgrp&#39; provided: {dhgrp} is not a valid fortigate phase1 &#34;
                                             &#34;proposal option&#34;)
            else:
                raise ValueError(&#34;dhgrp must be provided as type integer&#34;)

            self.dhgrp = dhgrp_items

    def set_p1_type(self, p1_type):
        &#34;&#34;&#34; Set self.pt_type to p1_type if p1_type is valid

        Args:
            p1_type (str): Phase1-interface type.  (&#39;dynamic&#39;, &#39;static&#39;, &#39;ddns&#39; or None=inherit)

        Returns:

        &#34;&#34;&#34;
        if p1_type is None:
            self.p1_type = None
        else:
            if isinstance(p1_type, str):
                if p1_type.lower() == &#39;dynamic&#39;:
                    self.p1_type = &#39;dynamic&#39;
                elif p1_type.lower() == &#39;static&#39;:
                    self.p1_type = &#39;static&#39;
                elif p1_type.lower() == &#39;ddns&#39;:
                    raise ValueError(&#34;p1_type of &#39;ddns&#39; is not yet supported&#34;)
                else:
                    raise ValueError(f&#34;&#39;p1_type&#39;: {p1_type} is not supported&#34;)
            else:
                raise ValueError(&#34;&#39;p1_type&#39;, when set, must be a str with value of &#39;dynamic&#39; or &#39;static&#39;&#34;)

    def set_interface(self, interface):
        &#34;&#34;&#34; set self.local_intfs to intf if intfs is valid

        Args:
            interface (str): Local interface for p1 attachment  (1 to 35 chars)

        Returns:
            None
        &#34;&#34;&#34;
        if interface is None:
            self.interface = None

        else:
            if interface.isspace(): raise ValueError(&#34;&#39;interface&#39;, cannot be an empty string&#34;)
            if isinstance(interface, str):
                if len(interface) &lt; 35:
                    self.interface = interface
                else:
                    raise ValueError(&#34;&#39;interface&#39;, when set, must be less than 35 chars or less&#34;)
            else:
                raise ValueError(&#34;&#39;interface&#39;, when set, must be a string&#34;)

    def set_ike_version(self, ike_version):
        &#34;&#34;&#34; Set self.ike_version to 1 or 2 if ike_version = 1 or 2.  Otherwise raise Exception

        Args:
            ike_version (int): ike-version.  (1 or 2)

        Returns:
            None
        &#34;&#34;&#34;
        if ike_version is None:
            self.ike_version = None
        else:
            if isinstance(ike_version, int):
                if ike_version == 1:
                    self.ike_version = 1
                elif ike_version == 2:
                    self.ike_version = 2
                else:
                    raise ValueError(&#34;&#39;ike_version&#39;, when set must be type int with value = &#39;1&#39; or &#39;2&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;ike_version&#39; when set, must be type int with value = &#39;1&#39; or &#39;2&#39;&#34;)

    def set_local_gw(self, local_gw):
        &#34;&#34;&#34; Set self.local_gw to local_gw if local_gw is valid ipv4 address

        Args:
            local_gw (str): Local gateway.  (valid ipv4 address as str())

        Returns:
            None
        &#34;&#34;&#34;
        if local_gw is None:
            self.local_gw = None
        else:
            try:
                self.local_gw = str(ipaddress.ip_address(local_gw))
            except ValueError:
                raise ValueError(&#34;&#39;local_gw&#39;, when set, must type str() with value containing a valid ipv4 address&#34;)


    def set_remote_gw(self, remote_gw):
        &#34;&#34;&#34; Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address

        Args:
            remote_gw (str): Address of remote vpn peer gateway.  (valid ipv4 address as str())

        Returns:
            None
        &#34;&#34;&#34;
        if remote_gw is None:
            self.remote_gw = None
        else:
            try:
                self.remote_gw = str(ipaddress.ip_address(remote_gw))
            except ValueError:
                raise ValueError(&#34;&#39;remote_gw&#39;, when set, must be type str() with value containing a valid ipv4 address&#34;)


    def set_psksecret(self, psk):
        &#34;&#34;&#34; Set self.psk to psk if psk valid

        Args:
            psk (str): Phase1 psksecret.  (6 to 30 chars)

        Returns:
            None
        &#34;&#34;&#34;
        if psk is None:
            self.psksecret = None
        else:
            if isinstance(psk, str):
                if 6 &lt;= len(psk) &lt;= 30:
                    self.psksecret = psk
                else:
                    raise ValueError(&#34;&#39;psksecret&#39;, must be type str() between 6 and 30 chars&#34;)
            else:
                raise ValueError(&#34;&#39;psksecret&#39;, must be type str()&#34;)

    def set_localid(self, localid):
        &#34;&#34;&#34; Set self.local_id to local_id if local_id is valid

        Args:
            localid (str): Phase1 local id.  (up to 68 chars)

       Returns:
            None
        &#34;&#34;&#34;
        if localid is None:
            self.localid = None
        else:
            if isinstance(localid, str):
                if 1 &lt;= len(localid) &lt;= 63:
                    self.localid = localid
                else:
                    raise ValueError(&#34;&#39;localid&#39;, when set, must be type str() between 1 and 63 chars&#34;)
            else:
                raise ValueError(&#34;&#39;localid&#39;, when set, must be type str()&#34;)

    def set_comment(self, comment):
        &#34;&#34;&#34; Set self.comment to comment if comment is valid

        Args:
            comment (str): Phase1 comment.  (up to 1023 chars)

        Returns:
            None
        &#34;&#34;&#34;
        if comment is None:
            self.comment = None
        else:
            if isinstance(comment, str):
                if 1 &lt;= len(comment) &lt;= 1023:
                    self.comment = comment
                else:
                    raise ValueError(&#34;&#39;description&#39;, when set, must be type str() between 1 and 1,023 chars&#34;)
            else:
                raise Exception(&#34;&#39;description&#39;, when set, must be type str()&#34;)

    def set_keepalive(self, keepalive):
        &#34;&#34;&#34; Set self.keepalive if keepalive valid

        Args:
            keepalive (int): phase1 keepalive  (10-900)

        Returns:
            None
        &#34;&#34;&#34;
        if keepalive is None:
            self.keepalive = None
        else:
            if isinstance(keepalive, int):
                if 10 &lt;= keepalive &lt;= 900:
                    self.keepalive = keepalive
                else:
                    raise ValueError(&#34;&#39;keepalive&#39;, when set, must be type int() between 10 and 900&#34;)
            else:
                raise ValueError(&#34;&#39;keepalive&#39;, when set, must be type int()&#34;)

    def set_add_route(self, add_route):
        &#34;&#34;&#34; Set self.add_route

        Args:
            add_route (str): add-route.  (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

        Returns:

        &#34;&#34;&#34;
        if add_route is None:
            self.add_route = None
        else:
            if isinstance(add_route, str):
                if add_route == &#39;enable&#39;:
                    self.add_route = &#39;enable&#39;
                elif add_route == &#39;disable&#39;:
                    self.add_route = &#39;disable&#39;
                else:
                    raise ValueError(&#34;&#39;add_route&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;add_route&#39;, when set, must be type str()&#34;)

    def set_add_gw_route(self, add_gw_route):
        &#34;&#34;&#34; Set self.add_gw_route

        Args:
            add_gw_route (str): add-gw-route. (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if add_gw_route is None:
            self.add_gw_route = None
        else:
            if isinstance(add_gw_route, str):
                if add_gw_route == &#39;enable&#39;:
                    self.add_gw_route = &#39;enable&#39;
                elif add_gw_route == &#39;disable&#39;:
                    self.add_gw_route = &#39;disable&#39;
                else:
                    raise ValueError(&#34;&#39;add_gw_route&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#34;)
            else:
                raise ValueError(&#34;&#39;add_gw_route&#39;, when set, must be type str()&#34;)

    def set_net_device(self, net_device):
        &#34;&#34;&#34; set self.net_device

        Args:
            net_device (str): net-device. (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if net_device is None:
            self.net_device = None
        else:
            if isinstance(net_device, str):
                if net_device == &#39;enable&#39;:
                    self.net_device = &#39;enable&#39;
                elif net_device == &#39;disable&#39;:
                    self.net_device = &#39;disable&#39;
                else:
                    raise ValueError(&#34;&#39;net_device&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;net_device&#39;, when set, must be type str()&#34;)

    def set_tunnel_search(self, tunnel_search):
        &#34;&#34;&#34; Set self.tunnel_search

        Args:
            tunnel_search (str): tunnel-search.  (&#39;selectors&#39;, &#39;nexthop&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if tunnel_search is None:
            self.tunnel_search = None
        else:
            if isinstance(tunnel_search, str):
                if tunnel_search.lower() == &#39;selectors&#39;:
                    self.tunnel_search = &#39;selectors&#39;
                elif tunnel_search.lower() == &#39;nexthop&#39;:
                    self.tunnel_search = &#39;nexthop&#39;
                else:
                    raise Exception(&#34;&#39;tunnel_search&#39; when set, must be type str() with value &#39;selectors&#39;, &#39;nexthop&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;tunnel_search&#39;, when set, must be type str(0&#34;)

    def set_dpd(self, dpd):
        &#34;&#34;&#34; Set self.dpd

        Args:
            dpd (str): phase1 dpd.   (&#39;disable&#39;, &#39;on-idle&#39;, &#39;on-demand&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if dpd is None:
            self.dpd = None
        else:
            if isinstance(dpd, str):
                if dpd.lower() == &#39;disable&#39;:
                    self.dpd = &#39;disable&#39;
                elif dpd.lower() == &#39;on-idle&#39;:
                    self.dpd = &#39;on-idle&#39;
                elif dpd.lower == &#39;on-demand&#39;:
                    self.dpd = &#39;on-demand&#39;
                else:
                    raise Exception(&#34;&#39;dpd&#39;, when set, must be type str() with value &#39;disable&#39;, &#39;on-idle&#39; or &#34;
                                    &#34;&#39;on-demmand&#34;)
            else:
                raise ValueError(&#34;&#39;dpd&#39;, when set, must be type str()&#34;)

    def set_nattraversal(self, nattraversal):
        &#34;&#34;&#34; Set self.nat_traversal

        Args:
            nattraversal (str): nat-traversal.  (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if nattraversal is None:
            self.nattraversal = None
        else:
            if isinstance(nattraversal, str):
                if nattraversal.lower() == &#39;enable&#39;:
                    self.nattraversal = &#39;enable&#39;
                elif nattraversal.lower() == &#39;disable&#39;:
                    self.nattraversal = &#39;disable&#39;
                elif nattraversal.lower() == &#39;forced&#39;:
                    self.nattraversal = &#39;forced&#39;
                else:
                    raise ValueError(&#34;&#39;nattraversal&#39;, when set, must be type str() with value &#39;enable&#39;, &#39;disable&#39; &#34;
                                    &#34;or &#39;forced&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;nattraversal&#39;, when set, must be type str()&#34;)

    def set_exchange_interface_ip(self, exchange_interface_ip):
        &#34;&#34;&#34; Set self.exchange_interface_ip

        Args:
            exchange_interface_ip (str): exchange-interface-ip. (&#39;enable&#39;, &#39;disable&#39; or None)

        Returns:
            None
        &#34;&#34;&#34;
        if exchange_interface_ip is None:
            self.exchange_interface_ip = None
        else:
            if isinstance(exchange_interface_ip, str):
                if exchange_interface_ip == &#39;enable&#39;:
                    self.exchange_interface_ip = &#39;enable&#39;
                elif exchange_interface_ip == &#39;disable&#39;:
                    self.exchange_interface_ip = &#39;disable&#39;
                else:
                    raise ValueError(&#34;exchange_interface_ip, when set, must be type str() with value &#39;enable&#39; or &#34;
                                     &#34;&#39;disable&#34;)
            else:
                raise ValueError(&#34;exchange_interface_ip, when set, must be type str()&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface"><code class="flex name class">
<span>class <span class="ident">FgIpsecP1Interface</span></span>
<span>(</span><span>name=None, p1_type=None, interface=None, proposal=None, ike_version=None, local_gw=None, psksecret=None, localid=None, remote_gw=None, add_route=None, add_gw_route=None, keepalive=None, net_device=None, comment=None, vdom=None, tunnel_search=None, dpd=None, dhgrp=None, nattraversal=None, exchange_interface_ip=None)</span>
</code></dt>
<dd>
<section class="desc"><p>FgIpsecP1Interface class represents FortiGate Firewall ipsec phase1 interface object and provides methods for
validating parameters and generating both cli and api configuration data for use in external configuration
applications</p>
<p>Currently supports dynamic or static VPN using psk authentication. No support yet for advpn or mode-cfg</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of ipsec phase1-interface object</dd>
<dt><strong><code>p1_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1-interface type</dd>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of locally attached fortigate interface</dd>
<dt><strong><code>proposal</code></strong> :&ensp;<code>list</code></dt>
<dd>Phase1-interface proposal(s)</dd>
<dt><strong><code>ike_version</code></strong> :&ensp;<code>int</code></dt>
<dd>ike version</dd>
<dt><strong><code>local_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1-interface local-gw IP</dd>
<dt><strong><code>psksecret</code></strong> :&ensp;<code>str</code></dt>
<dd>Pre-shared key</dd>
<dt><strong><code>localid</code></strong> :&ensp;<code>str</code></dt>
<dd>Local ID</dd>
<dt><strong><code>remote_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Remote Gateway</dd>
<dt><strong><code>add_route</code></strong> :&ensp;<code>str</code></dt>
<dd>add-route ('enable', 'disable', or None=inherit)</dd>
<dt><strong><code>add_gw_route</code></strong> :&ensp;<code>str</code></dt>
<dd>add-gw-route ('enable', 'disable', or None=inherit)</dd>
<dt><strong><code>keepalive</code></strong> :&ensp;<code>int</code></dt>
<dd>Keepalive in seconds</dd>
<dt><strong><code>net_device</code></strong> :&ensp;<code>str</code></dt>
<dd>net-device
('enable', 'disable', or None=inherit)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>phase1 comment</dd>
<dt><strong><code>vdom</code></strong> :&ensp;<code>str</code></dt>
<dd>Associated VDOM, if applicable</dd>
<dt><strong><code>tunnel_search</code></strong> :&ensp;<code>str</code></dt>
<dd>tunnel-search ('next-hop', 'selectors' or None=inherit)</dd>
<dt><strong><code>dpd</code></strong> :&ensp;<code>str</code></dt>
<dd>phase1 DPD ('on-demand', 'on-idle', 'disable' or None=inherit)</dd>
<dt><strong><code>dhgrp</code></strong> :&ensp;<code>str</code></dt>
<dd>dhgrp</dd>
<dt><strong><code>nattraversal</code></strong> :&ensp;<code>str</code></dt>
<dd>nattraversal ('enable', 'disable', 'forced' or None=inherit)</dd>
<dt><strong><code>exchange_interface_ip</code></strong> :&ensp;<code>str</code></dt>
<dd>exchange-interface-ip ('enable', 'disable', or None=inherit)</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Set name of ipsec phase1-interface object</dd>
<dt><strong><code>p1_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Set phase1-interface type</dd>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>Set name of locally attached fortigate interface</dd>
<dt><strong><code>proposal</code></strong> :&ensp;<code>list</code></dt>
<dd>Set phase1-interface proposal(s)</dd>
<dt><strong><code>ike_version</code></strong> :&ensp;<code>int</code></dt>
<dd>Set ike version</dd>
<dt><strong><code>local_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Set phase1-interface local-gw IP</dd>
<dt><strong><code>psksecret</code></strong> :&ensp;<code>str</code></dt>
<dd>Set pre-shared key</dd>
<dt><strong><code>localid</code></strong> :&ensp;<code>str</code></dt>
<dd>Set local ID</dd>
<dt><strong><code>remote_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Set remote Gateway</dd>
<dt><strong><code>add_route</code></strong> :&ensp;<code>str</code></dt>
<dd>Set add-route ('enable', 'disable', or None=inherit)</dd>
<dt><strong><code>add_gw_route</code></strong> :&ensp;<code>str</code></dt>
<dd>Set add-gw-route ('enable', 'disable', or None=inherit)</dd>
<dt><strong><code>keepalive</code></strong> :&ensp;<code>int</code></dt>
<dd>Set keepalive in seconds</dd>
<dt><strong><code>net_device</code></strong> :&ensp;<code>str</code></dt>
<dd>Set net-device ('enable', 'disable', or None=inherit)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Set phase1 comment</dd>
<dt><strong><code>vdom</code></strong> :&ensp;<code>str</code></dt>
<dd>Set associated VDOM, if applicable</dd>
<dt><strong><code>tunnel_search</code></strong> :&ensp;<code>str</code></dt>
<dd>Set tunnel-search ('next-hop', 'selectors' or None=inherit)</dd>
<dt><strong><code>dpd</code></strong> :&ensp;<code>list</code></dt>
<dd>Set phase1 DPD ('on-demand', 'on-idle', 'disable' or None=inherit)</dd>
<dt><strong><code>nattraversal</code></strong> :&ensp;<code>str</code></dt>
<dd>Set nattraversal ('enable', 'disable', 'forced' or None=inherit)</dd>
<dt><strong><code>exchange_interface_ip</code></strong> :&ensp;<code>str</code></dt>
<dd>Set exchange-interfce-ip ('enable', 'disable', or None=inherit)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FgIpsecP1Interface(FgObject):
    &#34;&#34;&#34; FgIpsecP1Interface class represents FortiGate Firewall ipsec phase1 interface object and provides methods for
    validating parameters and generating both cli and api configuration data for use in external configuration
    applications

    Currently supports dynamic or static VPN using psk authentication. No support yet for advpn or mode-cfg

    Attributes:
        name (str): Name of ipsec phase1-interface object
        p1_type (str): Phase1-interface type
        interface (str): Name of locally attached fortigate interface
        proposal (list): Phase1-interface proposal(s)
        ike_version (int): ike version
        local_gw (str): Phase1-interface local-gw IP
        psksecret (str): Pre-shared key
        localid (str): Local ID
        remote_gw (str): Remote Gateway
        add_route (str):  add-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        add_gw_route (str): add-gw-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        keepalive (int): Keepalive in seconds
        net_device (str): net-device  (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        comment (str): phase1 comment
        vdom (str): Associated VDOM, if applicable
        tunnel_search (str):  tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
        dpd (str): phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
        dhgrp (str): dhgrp
        nattraversal (str): nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
        exchange_interface_ip (str): exchange-interface-ip (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
    &#34;&#34;&#34;

    def __init__(self, name: str = None, p1_type: str = None, interface: str = None, proposal: list = None,
                 ike_version: int = None, local_gw: str = None, psksecret: str = None, localid: str = None,
                 remote_gw: str = None, add_route: str = None, add_gw_route: str = None, keepalive: int = None,
                 net_device: str = None, comment: str = None, vdom: str = None, tunnel_search: str = None,
                 dpd: str = None, dhgrp: list = None, nattraversal: str = None, exchange_interface_ip: str = None):

        &#34;&#34;&#34;
        Args:
            name (str): Set name of ipsec phase1-interface object
            p1_type (str): Set phase1-interface type
            interface (str): Set name of locally attached fortigate interface
            proposal (list): Set phase1-interface proposal(s)
            ike_version (int): Set ike version
            local_gw (str): Set phase1-interface local-gw IP
            psksecret (str): Set pre-shared key
            localid (str): Set local ID
            remote_gw (str): Set remote Gateway
            add_route (str):  Set add-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
            add_gw_route (str): Set add-gw-route (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
            keepalive (int): Set keepalive in seconds
            net_device (str): Set net-device (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
            comment (str): Set phase1 comment
            vdom (str): Set associated VDOM, if applicable
            tunnel_search (str):  Set tunnel-search (&#39;next-hop&#39;, &#39;selectors&#39; or None=inherit)
            dpd (list): Set phase1 DPD (&#39;on-demand&#39;, &#39;on-idle&#39;, &#39;disable&#39; or None=inherit)
            nattraversal (str): Set nattraversal (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39; or None=inherit)
            exchange_interface_ip (str): Set exchange-interfce-ip (&#39;enable&#39;, &#39;disable&#39;, or None=inherit)
        &#34;&#34;&#34;

        # Initialize the parent class
        super().__init__(api=&#39;cmdb&#39;, api_path=&#39;vpn.ipsec&#39;, api_name=&#39;phase1-interface&#39;,
                         cli_path=&#34;config vpn ipsec phase1-interface&#34;, obj_id=name, vdom=vdom)

        ### Set parent class attributes ###
        # CLI config path for this object type
        self.cli_path = &#34;config vpn ipsec phase1-interface&#34;

        # Map instance attribute names to fg attribute names
        self.data_attrs = {&#39;name&#39;: &#39;name&#39;, &#39;p1_type&#39;: &#39;type&#39;, &#39;interface&#39;: &#39;interface&#39;, &#39;proposal&#39;: &#39;proposal&#39;,
                           &#39;ike_version&#39;: &#39;ike-version&#39;, &#39;local_gw&#39;: &#39;local-gw&#39;, &#39;psksecret&#39;: &#39;psksecret&#39;,
                           &#39;localid&#39;: &#39;localid&#39;, &#39;remote_gw&#39;: &#39;remote-gw&#39;, &#39;comment&#39;: &#39;comments&#39;,
                           &#39;add_route&#39;: &#39;add-route&#39;, &#39;add_gw_route&#39;: &#39;add-gw-route&#39;, &#39;keepalive&#39;: &#39;keepalive&#39;,
                           &#39;net_device&#39;: &#39;net-device&#39;, &#39;tunnel_search&#39;: &#39;tunnel-search&#39;, &#39;dpd&#39;: &#39;dpd&#39;, &#39;dhgrp&#39;: &#39;dhgrp&#39;,
                           &#39;nattraversal&#39;: &#39;nattraversal&#39;, &#39;exchange_interface_ip&#39;: &#39;exchange-interface-ip&#39;}

        self.cli_ignore_attrs = [&#39;name&#39;]

        # Set instance attributes
        self.set_name(name)
        self.set_p1_type(p1_type)
        self.set_interface(interface)
        self.set_proposal(proposal)
        self.set_ike_version(ike_version)
        self.set_local_gw(local_gw)
        self.set_psksecret(psksecret)
        self.set_localid(localid)
        self.set_remote_gw(remote_gw)
        self.set_comment(comment)
        self.set_add_route(add_route)
        self.set_keepalive(keepalive)
        self.set_add_gw_route(add_gw_route)
        self.set_net_device(net_device)
        self.set_tunnel_search(tunnel_search)
        self.set_dpd(dpd)
        self.set_dhgrp(dhgrp)
        self.set_nattraversal(nattraversal)
        self.set_exchange_interface_ip(exchange_interface_ip)

        self.obj_to_str += f&#39;, name={name}, p1_type={p1_type}, interface={self.interface}, &#39; \
                          f&#39;proposal={self.proposal}, ike_version={self.ike_version}, local_gw={self.local_gw}, &#39; \
                          f&#39;psksecret={self.psksecret}, localid={self.localid}, remote_gw={self.remote_gw}, &#39; \
                          f&#39;comment={self.comment}, add_route={self.add_route}, add_gw_route={self.add_gw_route}, &#39; \
                          f&#39;keepalive={self.keepalive}, net_device={self.net_device}, &#39; \
                          f&#39;tunnel_search={self.tunnel_search}, dpd={self.dpd}, dhgrp={self.dhgrp},&#39; \
                          f&#39;nattraversal={self.nattraversal}, exchange_interface_ip={self.exchange_interface_ip}&#39;


    # Instance Methods
    def set_name(self, name):
        &#34;&#34;&#34; Set self.name to name if name is valid

        Args:
            name: Name of object

        Returns:
            None
        &#34;&#34;&#34;
        if name is None:
            self.name = None

        else:
            if name.isspace(): raise Exception(&#34;&#39;name&#39;, cannot be an empty string&#34;)
            if isinstance(name, str):
                if len(name) &lt;= 35:
                    self.name = name
                else:
                    raise Exception(&#34;&#39;name&#39;, must be less than 35 chars or less&#34;)
            else:
                raise Exception(&#34;&#39;name&#39;, must be a string&#34;)

    def set_proposal(self, proposal):
        &#34;&#34;&#34; Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals

        Args:
            proposal (list): string containing a single p1 proposal or list of strings with one or more p1 propolsals

        Returns:
            None
        &#34;&#34;&#34;
        valid_proposals = [&#39;des-md5&#39;, &#39;des-sha&#39;, &#39;des-sha256&#39;, &#39;des-sha384&#39;, &#39;des-sha512&#39;, &#39;3des-md5&#39;, &#39;3des-sha1&#39;,
                           &#39;3des-sha256&#39;, &#39;3des-sha384&#39;, &#39;3des-sha512&#39;, &#39;aes128-md5&#39;, &#39;aes128-sha1&#39;, &#39;aes128-sha256&#39;,
                           &#39;aes128-sha384&#39;, &#39;aes128-sha512&#39;, &#39;aes192-md5&#39;, &#39;aes192-sha1&#39;, &#39;aes192-sha256&#39;,
                           &#39;aes192-sha384&#39;, &#39;aes192-sha512&#39;, &#39;aes256-md5&#39;, &#39;aes256-sha1&#39;, &#39;aes256-sha256&#39;,
                           &#39;aes256-sha384&#39;, &#39;aes256-sha512&#39;, &#39;aria128-md5&#39;, &#39;aria128-sha1&#39;, &#39;aria128-sha256&#39;,
                           &#39;aria128-sha384&#39;, &#39;aria128-sha512&#39;, &#39;aria192-md5&#39;, &#39;aria192-sha1&#39;, &#39;aria192-sha256&#39;,
                           &#39;aria192-sha384&#39;, &#39;aria192-sha512&#39;, &#39;aria256-md5&#39;, &#39;aria256-sha1&#39;, &#39;aria256-sha256&#39;,
                           &#39;aria256-sha384&#39;, &#39;aria256-sha512&#39;, &#39;seed-md5&#39;, &#39;seed-sha1&#39;, &#39;seed-sha256&#39;, &#39;seed-sha384&#39;,
                           &#39;seed-sha512&#39;]

        if proposal is None:
            self.proposal = None

        else:
            proposal_items = &#39;&#39;

            # IF a single object was passed as a string, append it to intf_list else iterate the list and pull
            # out the strings of interfaces and append each to intf_list
            if isinstance(proposal, str):

                # compare proposal to valid_proposals list
                if proposal in valid_proposals:
                    proposal_items += f&#34;{proposal} &#34;
                else:
                    raise ValueError(f&#34;&#39;proposal&#39; provided: {proposal} is not a valid FortiGate phase1 proposal&#34;)

            elif isinstance(proposal, list):
                for item in proposal:
                    if isinstance(item, str):

                        # compare proposal to valid proposals list
                        if item in valid_proposals:
                            proposal_items += f&#34;{item} &#34;
                        else:
                            raise ValueError(&#34;&#39;proposal&#39; provided: {proposal} is not a valid FortiGate phase1 proposal&#34;)
            else:
                raise ValueError(&#34;proposal must be provided as type string (with single proposal referenced or as a &#34;
                                 &#34;list for multiple proposal references&#34;)

            self.proposal = proposal_items

    def set_dhgrp(self, dhgrp):
        &#34;&#34;&#34; Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp

        The dhgrp may be passed in as a str, or a list.  If the dhgrp(s) passed in are valid, add each
        of those to a space separated values string and set in self.dhgrp

        Args:
            dhgrp (list): single int representing one dhgrp or a list of ints for one or more dhgrps

        Returns:
            None
        &#34;&#34;&#34;
        if dhgrp is None:
            self.dhgrp = None

        else:
            dhgrp_items = &#39;&#39;
            valid_dhgrps = [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 27, 28, 30, 31, 32]

            # IF a single object was passed as a string, append it to list else iterate the list and pull
            # out the dhgrps and add to list to be set as self object
            if isinstance(dhgrp, int):
                # compare proposal to valid_list
                if dhgrp in valid_dhgrps:
                    dhgrp_items += &#34;{} &#34;.format(dhgrp)
                else:
                    raise ValueError(f&#34;&#39;dhgrp&#39; provided: {dhgrp}, is not a valid fortigate dhgrp&#34;)

            elif isinstance(dhgrp, list):
                for item in dhgrp:
                    if isinstance(item, int):

                        # compare proposal to valid proposals list
                        if item in valid_dhgrps:
                            dhgrp_items += &#34;{} &#34;.format(item)
                        else:
                            raise ValueError(f&#34;At least one &#39;dhgrp&#39; provided: {dhgrp} is not a valid fortigate phase1 &#34;
                                             &#34;proposal option&#34;)
            else:
                raise ValueError(&#34;dhgrp must be provided as type integer&#34;)

            self.dhgrp = dhgrp_items

    def set_p1_type(self, p1_type):
        &#34;&#34;&#34; Set self.pt_type to p1_type if p1_type is valid

        Args:
            p1_type (str): Phase1-interface type.  (&#39;dynamic&#39;, &#39;static&#39;, &#39;ddns&#39; or None=inherit)

        Returns:

        &#34;&#34;&#34;
        if p1_type is None:
            self.p1_type = None
        else:
            if isinstance(p1_type, str):
                if p1_type.lower() == &#39;dynamic&#39;:
                    self.p1_type = &#39;dynamic&#39;
                elif p1_type.lower() == &#39;static&#39;:
                    self.p1_type = &#39;static&#39;
                elif p1_type.lower() == &#39;ddns&#39;:
                    raise ValueError(&#34;p1_type of &#39;ddns&#39; is not yet supported&#34;)
                else:
                    raise ValueError(f&#34;&#39;p1_type&#39;: {p1_type} is not supported&#34;)
            else:
                raise ValueError(&#34;&#39;p1_type&#39;, when set, must be a str with value of &#39;dynamic&#39; or &#39;static&#39;&#34;)

    def set_interface(self, interface):
        &#34;&#34;&#34; set self.local_intfs to intf if intfs is valid

        Args:
            interface (str): Local interface for p1 attachment  (1 to 35 chars)

        Returns:
            None
        &#34;&#34;&#34;
        if interface is None:
            self.interface = None

        else:
            if interface.isspace(): raise ValueError(&#34;&#39;interface&#39;, cannot be an empty string&#34;)
            if isinstance(interface, str):
                if len(interface) &lt; 35:
                    self.interface = interface
                else:
                    raise ValueError(&#34;&#39;interface&#39;, when set, must be less than 35 chars or less&#34;)
            else:
                raise ValueError(&#34;&#39;interface&#39;, when set, must be a string&#34;)

    def set_ike_version(self, ike_version):
        &#34;&#34;&#34; Set self.ike_version to 1 or 2 if ike_version = 1 or 2.  Otherwise raise Exception

        Args:
            ike_version (int): ike-version.  (1 or 2)

        Returns:
            None
        &#34;&#34;&#34;
        if ike_version is None:
            self.ike_version = None
        else:
            if isinstance(ike_version, int):
                if ike_version == 1:
                    self.ike_version = 1
                elif ike_version == 2:
                    self.ike_version = 2
                else:
                    raise ValueError(&#34;&#39;ike_version&#39;, when set must be type int with value = &#39;1&#39; or &#39;2&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;ike_version&#39; when set, must be type int with value = &#39;1&#39; or &#39;2&#39;&#34;)

    def set_local_gw(self, local_gw):
        &#34;&#34;&#34; Set self.local_gw to local_gw if local_gw is valid ipv4 address

        Args:
            local_gw (str): Local gateway.  (valid ipv4 address as str())

        Returns:
            None
        &#34;&#34;&#34;
        if local_gw is None:
            self.local_gw = None
        else:
            try:
                self.local_gw = str(ipaddress.ip_address(local_gw))
            except ValueError:
                raise ValueError(&#34;&#39;local_gw&#39;, when set, must type str() with value containing a valid ipv4 address&#34;)


    def set_remote_gw(self, remote_gw):
        &#34;&#34;&#34; Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address

        Args:
            remote_gw (str): Address of remote vpn peer gateway.  (valid ipv4 address as str())

        Returns:
            None
        &#34;&#34;&#34;
        if remote_gw is None:
            self.remote_gw = None
        else:
            try:
                self.remote_gw = str(ipaddress.ip_address(remote_gw))
            except ValueError:
                raise ValueError(&#34;&#39;remote_gw&#39;, when set, must be type str() with value containing a valid ipv4 address&#34;)


    def set_psksecret(self, psk):
        &#34;&#34;&#34; Set self.psk to psk if psk valid

        Args:
            psk (str): Phase1 psksecret.  (6 to 30 chars)

        Returns:
            None
        &#34;&#34;&#34;
        if psk is None:
            self.psksecret = None
        else:
            if isinstance(psk, str):
                if 6 &lt;= len(psk) &lt;= 30:
                    self.psksecret = psk
                else:
                    raise ValueError(&#34;&#39;psksecret&#39;, must be type str() between 6 and 30 chars&#34;)
            else:
                raise ValueError(&#34;&#39;psksecret&#39;, must be type str()&#34;)

    def set_localid(self, localid):
        &#34;&#34;&#34; Set self.local_id to local_id if local_id is valid

        Args:
            localid (str): Phase1 local id.  (up to 68 chars)

       Returns:
            None
        &#34;&#34;&#34;
        if localid is None:
            self.localid = None
        else:
            if isinstance(localid, str):
                if 1 &lt;= len(localid) &lt;= 63:
                    self.localid = localid
                else:
                    raise ValueError(&#34;&#39;localid&#39;, when set, must be type str() between 1 and 63 chars&#34;)
            else:
                raise ValueError(&#34;&#39;localid&#39;, when set, must be type str()&#34;)

    def set_comment(self, comment):
        &#34;&#34;&#34; Set self.comment to comment if comment is valid

        Args:
            comment (str): Phase1 comment.  (up to 1023 chars)

        Returns:
            None
        &#34;&#34;&#34;
        if comment is None:
            self.comment = None
        else:
            if isinstance(comment, str):
                if 1 &lt;= len(comment) &lt;= 1023:
                    self.comment = comment
                else:
                    raise ValueError(&#34;&#39;description&#39;, when set, must be type str() between 1 and 1,023 chars&#34;)
            else:
                raise Exception(&#34;&#39;description&#39;, when set, must be type str()&#34;)

    def set_keepalive(self, keepalive):
        &#34;&#34;&#34; Set self.keepalive if keepalive valid

        Args:
            keepalive (int): phase1 keepalive  (10-900)

        Returns:
            None
        &#34;&#34;&#34;
        if keepalive is None:
            self.keepalive = None
        else:
            if isinstance(keepalive, int):
                if 10 &lt;= keepalive &lt;= 900:
                    self.keepalive = keepalive
                else:
                    raise ValueError(&#34;&#39;keepalive&#39;, when set, must be type int() between 10 and 900&#34;)
            else:
                raise ValueError(&#34;&#39;keepalive&#39;, when set, must be type int()&#34;)

    def set_add_route(self, add_route):
        &#34;&#34;&#34; Set self.add_route

        Args:
            add_route (str): add-route.  (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

        Returns:

        &#34;&#34;&#34;
        if add_route is None:
            self.add_route = None
        else:
            if isinstance(add_route, str):
                if add_route == &#39;enable&#39;:
                    self.add_route = &#39;enable&#39;
                elif add_route == &#39;disable&#39;:
                    self.add_route = &#39;disable&#39;
                else:
                    raise ValueError(&#34;&#39;add_route&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;add_route&#39;, when set, must be type str()&#34;)

    def set_add_gw_route(self, add_gw_route):
        &#34;&#34;&#34; Set self.add_gw_route

        Args:
            add_gw_route (str): add-gw-route. (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if add_gw_route is None:
            self.add_gw_route = None
        else:
            if isinstance(add_gw_route, str):
                if add_gw_route == &#39;enable&#39;:
                    self.add_gw_route = &#39;enable&#39;
                elif add_gw_route == &#39;disable&#39;:
                    self.add_gw_route = &#39;disable&#39;
                else:
                    raise ValueError(&#34;&#39;add_gw_route&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#34;)
            else:
                raise ValueError(&#34;&#39;add_gw_route&#39;, when set, must be type str()&#34;)

    def set_net_device(self, net_device):
        &#34;&#34;&#34; set self.net_device

        Args:
            net_device (str): net-device. (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if net_device is None:
            self.net_device = None
        else:
            if isinstance(net_device, str):
                if net_device == &#39;enable&#39;:
                    self.net_device = &#39;enable&#39;
                elif net_device == &#39;disable&#39;:
                    self.net_device = &#39;disable&#39;
                else:
                    raise ValueError(&#34;&#39;net_device&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;net_device&#39;, when set, must be type str()&#34;)

    def set_tunnel_search(self, tunnel_search):
        &#34;&#34;&#34; Set self.tunnel_search

        Args:
            tunnel_search (str): tunnel-search.  (&#39;selectors&#39;, &#39;nexthop&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if tunnel_search is None:
            self.tunnel_search = None
        else:
            if isinstance(tunnel_search, str):
                if tunnel_search.lower() == &#39;selectors&#39;:
                    self.tunnel_search = &#39;selectors&#39;
                elif tunnel_search.lower() == &#39;nexthop&#39;:
                    self.tunnel_search = &#39;nexthop&#39;
                else:
                    raise Exception(&#34;&#39;tunnel_search&#39; when set, must be type str() with value &#39;selectors&#39;, &#39;nexthop&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;tunnel_search&#39;, when set, must be type str(0&#34;)

    def set_dpd(self, dpd):
        &#34;&#34;&#34; Set self.dpd

        Args:
            dpd (str): phase1 dpd.   (&#39;disable&#39;, &#39;on-idle&#39;, &#39;on-demand&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if dpd is None:
            self.dpd = None
        else:
            if isinstance(dpd, str):
                if dpd.lower() == &#39;disable&#39;:
                    self.dpd = &#39;disable&#39;
                elif dpd.lower() == &#39;on-idle&#39;:
                    self.dpd = &#39;on-idle&#39;
                elif dpd.lower == &#39;on-demand&#39;:
                    self.dpd = &#39;on-demand&#39;
                else:
                    raise Exception(&#34;&#39;dpd&#39;, when set, must be type str() with value &#39;disable&#39;, &#39;on-idle&#39; or &#34;
                                    &#34;&#39;on-demmand&#34;)
            else:
                raise ValueError(&#34;&#39;dpd&#39;, when set, must be type str()&#34;)

    def set_nattraversal(self, nattraversal):
        &#34;&#34;&#34; Set self.nat_traversal

        Args:
            nattraversal (str): nat-traversal.  (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39;, None=inherit)

        Returns:
            None
        &#34;&#34;&#34;
        if nattraversal is None:
            self.nattraversal = None
        else:
            if isinstance(nattraversal, str):
                if nattraversal.lower() == &#39;enable&#39;:
                    self.nattraversal = &#39;enable&#39;
                elif nattraversal.lower() == &#39;disable&#39;:
                    self.nattraversal = &#39;disable&#39;
                elif nattraversal.lower() == &#39;forced&#39;:
                    self.nattraversal = &#39;forced&#39;
                else:
                    raise ValueError(&#34;&#39;nattraversal&#39;, when set, must be type str() with value &#39;enable&#39;, &#39;disable&#39; &#34;
                                    &#34;or &#39;forced&#39;&#34;)
            else:
                raise ValueError(&#34;&#39;nattraversal&#39;, when set, must be type str()&#34;)

    def set_exchange_interface_ip(self, exchange_interface_ip):
        &#34;&#34;&#34; Set self.exchange_interface_ip

        Args:
            exchange_interface_ip (str): exchange-interface-ip. (&#39;enable&#39;, &#39;disable&#39; or None)

        Returns:
            None
        &#34;&#34;&#34;
        if exchange_interface_ip is None:
            self.exchange_interface_ip = None
        else:
            if isinstance(exchange_interface_ip, str):
                if exchange_interface_ip == &#39;enable&#39;:
                    self.exchange_interface_ip = &#39;enable&#39;
                elif exchange_interface_ip == &#39;disable&#39;:
                    self.exchange_interface_ip = &#39;disable&#39;
                else:
                    raise ValueError(&#34;exchange_interface_ip, when set, must be type str() with value &#39;enable&#39; or &#34;
                                     &#34;&#39;disable&#34;)
            else:
                raise ValueError(&#34;exchange_interface_ip, when set, must be type str()&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fgobjlib.fg_object.FgObject" href="fg_object.html#fgobjlib.fg_object.FgObject">FgObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_gw_route"><code class="name flex">
<span>def <span class="ident">set_add_gw_route</span></span>(<span>self, add_gw_route)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.add_gw_route</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>add_gw_route</code></strong> :&ensp;<code>str</code></dt>
<dd>add-gw-route. ('enable', 'disable' or None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_add_gw_route(self, add_gw_route):
    &#34;&#34;&#34; Set self.add_gw_route

    Args:
        add_gw_route (str): add-gw-route. (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if add_gw_route is None:
        self.add_gw_route = None
    else:
        if isinstance(add_gw_route, str):
            if add_gw_route == &#39;enable&#39;:
                self.add_gw_route = &#39;enable&#39;
            elif add_gw_route == &#39;disable&#39;:
                self.add_gw_route = &#39;disable&#39;
            else:
                raise ValueError(&#34;&#39;add_gw_route&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#34;)
        else:
            raise ValueError(&#34;&#39;add_gw_route&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_route"><code class="name flex">
<span>def <span class="ident">set_add_route</span></span>(<span>self, add_route)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.add_route</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>add_route</code></strong> :&ensp;<code>str</code></dt>
<dd>add-route.
('enable', 'disable' or None=inherit)</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_add_route(self, add_route):
    &#34;&#34;&#34; Set self.add_route

    Args:
        add_route (str): add-route.  (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

    Returns:

    &#34;&#34;&#34;
    if add_route is None:
        self.add_route = None
    else:
        if isinstance(add_route, str):
            if add_route == &#39;enable&#39;:
                self.add_route = &#39;enable&#39;
            elif add_route == &#39;disable&#39;:
                self.add_route = &#39;disable&#39;
            else:
                raise ValueError(&#34;&#39;add_route&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#39;&#34;)
        else:
            raise ValueError(&#34;&#39;add_route&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_comment"><code class="name flex">
<span>def <span class="ident">set_comment</span></span>(<span>self, comment)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.comment to comment if comment is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1 comment.
(up to 1023 chars)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_comment(self, comment):
    &#34;&#34;&#34; Set self.comment to comment if comment is valid

    Args:
        comment (str): Phase1 comment.  (up to 1023 chars)

    Returns:
        None
    &#34;&#34;&#34;
    if comment is None:
        self.comment = None
    else:
        if isinstance(comment, str):
            if 1 &lt;= len(comment) &lt;= 1023:
                self.comment = comment
            else:
                raise ValueError(&#34;&#39;description&#39;, when set, must be type str() between 1 and 1,023 chars&#34;)
        else:
            raise Exception(&#34;&#39;description&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dhgrp"><code class="name flex">
<span>def <span class="ident">set_dhgrp</span></span>(<span>self, dhgrp)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp</p>
<p>The dhgrp may be passed in as a str, or a list.
If the dhgrp(s) passed in are valid, add each
of those to a space separated values string and set in self.dhgrp</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dhgrp</code></strong> :&ensp;<code>list</code></dt>
<dd>single int representing one dhgrp or a list of ints for one or more dhgrps</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dhgrp(self, dhgrp):
    &#34;&#34;&#34; Set self.dhgrp to dhgrp if dhgrp is valid ForitGate dhgrp

    The dhgrp may be passed in as a str, or a list.  If the dhgrp(s) passed in are valid, add each
    of those to a space separated values string and set in self.dhgrp

    Args:
        dhgrp (list): single int representing one dhgrp or a list of ints for one or more dhgrps

    Returns:
        None
    &#34;&#34;&#34;
    if dhgrp is None:
        self.dhgrp = None

    else:
        dhgrp_items = &#39;&#39;
        valid_dhgrps = [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 27, 28, 30, 31, 32]

        # IF a single object was passed as a string, append it to list else iterate the list and pull
        # out the dhgrps and add to list to be set as self object
        if isinstance(dhgrp, int):
            # compare proposal to valid_list
            if dhgrp in valid_dhgrps:
                dhgrp_items += &#34;{} &#34;.format(dhgrp)
            else:
                raise ValueError(f&#34;&#39;dhgrp&#39; provided: {dhgrp}, is not a valid fortigate dhgrp&#34;)

        elif isinstance(dhgrp, list):
            for item in dhgrp:
                if isinstance(item, int):

                    # compare proposal to valid proposals list
                    if item in valid_dhgrps:
                        dhgrp_items += &#34;{} &#34;.format(item)
                    else:
                        raise ValueError(f&#34;At least one &#39;dhgrp&#39; provided: {dhgrp} is not a valid fortigate phase1 &#34;
                                         &#34;proposal option&#34;)
        else:
            raise ValueError(&#34;dhgrp must be provided as type integer&#34;)

        self.dhgrp = dhgrp_items</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dpd"><code class="name flex">
<span>def <span class="ident">set_dpd</span></span>(<span>self, dpd)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.dpd</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dpd</code></strong> :&ensp;<code>str</code></dt>
<dd>phase1 dpd.
('disable', 'on-idle', 'on-demand', None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dpd(self, dpd):
    &#34;&#34;&#34; Set self.dpd

    Args:
        dpd (str): phase1 dpd.   (&#39;disable&#39;, &#39;on-idle&#39;, &#39;on-demand&#39;, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if dpd is None:
        self.dpd = None
    else:
        if isinstance(dpd, str):
            if dpd.lower() == &#39;disable&#39;:
                self.dpd = &#39;disable&#39;
            elif dpd.lower() == &#39;on-idle&#39;:
                self.dpd = &#39;on-idle&#39;
            elif dpd.lower == &#39;on-demand&#39;:
                self.dpd = &#39;on-demand&#39;
            else:
                raise Exception(&#34;&#39;dpd&#39;, when set, must be type str() with value &#39;disable&#39;, &#39;on-idle&#39; or &#34;
                                &#34;&#39;on-demmand&#34;)
        else:
            raise ValueError(&#34;&#39;dpd&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_exchange_interface_ip"><code class="name flex">
<span>def <span class="ident">set_exchange_interface_ip</span></span>(<span>self, exchange_interface_ip)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.exchange_interface_ip</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exchange_interface_ip</code></strong> :&ensp;<code>str</code></dt>
<dd>exchange-interface-ip. ('enable', 'disable' or None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_exchange_interface_ip(self, exchange_interface_ip):
    &#34;&#34;&#34; Set self.exchange_interface_ip

    Args:
        exchange_interface_ip (str): exchange-interface-ip. (&#39;enable&#39;, &#39;disable&#39; or None)

    Returns:
        None
    &#34;&#34;&#34;
    if exchange_interface_ip is None:
        self.exchange_interface_ip = None
    else:
        if isinstance(exchange_interface_ip, str):
            if exchange_interface_ip == &#39;enable&#39;:
                self.exchange_interface_ip = &#39;enable&#39;
            elif exchange_interface_ip == &#39;disable&#39;:
                self.exchange_interface_ip = &#39;disable&#39;
            else:
                raise ValueError(&#34;exchange_interface_ip, when set, must be type str() with value &#39;enable&#39; or &#34;
                                 &#34;&#39;disable&#34;)
        else:
            raise ValueError(&#34;exchange_interface_ip, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_ike_version"><code class="name flex">
<span>def <span class="ident">set_ike_version</span></span>(<span>self, ike_version)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.ike_version to 1 or 2 if ike_version = 1 or 2.
Otherwise raise Exception</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ike_version</code></strong> :&ensp;<code>int</code></dt>
<dd>ike-version.
(1 or 2)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ike_version(self, ike_version):
    &#34;&#34;&#34; Set self.ike_version to 1 or 2 if ike_version = 1 or 2.  Otherwise raise Exception

    Args:
        ike_version (int): ike-version.  (1 or 2)

    Returns:
        None
    &#34;&#34;&#34;
    if ike_version is None:
        self.ike_version = None
    else:
        if isinstance(ike_version, int):
            if ike_version == 1:
                self.ike_version = 1
            elif ike_version == 2:
                self.ike_version = 2
            else:
                raise ValueError(&#34;&#39;ike_version&#39;, when set must be type int with value = &#39;1&#39; or &#39;2&#39;&#34;)
        else:
            raise ValueError(&#34;&#39;ike_version&#39; when set, must be type int with value = &#39;1&#39; or &#39;2&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_interface"><code class="name flex">
<span>def <span class="ident">set_interface</span></span>(<span>self, interface)</span>
</code></dt>
<dd>
<section class="desc"><p>set self.local_intfs to intf if intfs is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>Local interface for p1 attachment
(1 to 35 chars)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_interface(self, interface):
    &#34;&#34;&#34; set self.local_intfs to intf if intfs is valid

    Args:
        interface (str): Local interface for p1 attachment  (1 to 35 chars)

    Returns:
        None
    &#34;&#34;&#34;
    if interface is None:
        self.interface = None

    else:
        if interface.isspace(): raise ValueError(&#34;&#39;interface&#39;, cannot be an empty string&#34;)
        if isinstance(interface, str):
            if len(interface) &lt; 35:
                self.interface = interface
            else:
                raise ValueError(&#34;&#39;interface&#39;, when set, must be less than 35 chars or less&#34;)
        else:
            raise ValueError(&#34;&#39;interface&#39;, when set, must be a string&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_keepalive"><code class="name flex">
<span>def <span class="ident">set_keepalive</span></span>(<span>self, keepalive)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.keepalive if keepalive valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keepalive</code></strong> :&ensp;<code>int</code></dt>
<dd>phase1 keepalive
(10-900)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_keepalive(self, keepalive):
    &#34;&#34;&#34; Set self.keepalive if keepalive valid

    Args:
        keepalive (int): phase1 keepalive  (10-900)

    Returns:
        None
    &#34;&#34;&#34;
    if keepalive is None:
        self.keepalive = None
    else:
        if isinstance(keepalive, int):
            if 10 &lt;= keepalive &lt;= 900:
                self.keepalive = keepalive
            else:
                raise ValueError(&#34;&#39;keepalive&#39;, when set, must be type int() between 10 and 900&#34;)
        else:
            raise ValueError(&#34;&#39;keepalive&#39;, when set, must be type int()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_gw"><code class="name flex">
<span>def <span class="ident">set_local_gw</span></span>(<span>self, local_gw)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.local_gw to local_gw if local_gw is valid ipv4 address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Local gateway.
(valid ipv4 address as str())</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_local_gw(self, local_gw):
    &#34;&#34;&#34; Set self.local_gw to local_gw if local_gw is valid ipv4 address

    Args:
        local_gw (str): Local gateway.  (valid ipv4 address as str())

    Returns:
        None
    &#34;&#34;&#34;
    if local_gw is None:
        self.local_gw = None
    else:
        try:
            self.local_gw = str(ipaddress.ip_address(local_gw))
        except ValueError:
            raise ValueError(&#34;&#39;local_gw&#39;, when set, must type str() with value containing a valid ipv4 address&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_localid"><code class="name flex">
<span>def <span class="ident">set_localid</span></span>(<span>self, localid)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.local_id to local_id if local_id is valid</p>
<p>Args:
localid (str): Phase1 local id.
(up to 68 chars)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_localid(self, localid):
    &#34;&#34;&#34; Set self.local_id to local_id if local_id is valid

    Args:
        localid (str): Phase1 local id.  (up to 68 chars)

   Returns:
        None
    &#34;&#34;&#34;
    if localid is None:
        self.localid = None
    else:
        if isinstance(localid, str):
            if 1 &lt;= len(localid) &lt;= 63:
                self.localid = localid
            else:
                raise ValueError(&#34;&#39;localid&#39;, when set, must be type str() between 1 and 63 chars&#34;)
        else:
            raise ValueError(&#34;&#39;localid&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.name to name if name is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    &#34;&#34;&#34; Set self.name to name if name is valid

    Args:
        name: Name of object

    Returns:
        None
    &#34;&#34;&#34;
    if name is None:
        self.name = None

    else:
        if name.isspace(): raise Exception(&#34;&#39;name&#39;, cannot be an empty string&#34;)
        if isinstance(name, str):
            if len(name) &lt;= 35:
                self.name = name
            else:
                raise Exception(&#34;&#39;name&#39;, must be less than 35 chars or less&#34;)
        else:
            raise Exception(&#34;&#39;name&#39;, must be a string&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_nattraversal"><code class="name flex">
<span>def <span class="ident">set_nattraversal</span></span>(<span>self, nattraversal)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.nat_traversal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nattraversal</code></strong> :&ensp;<code>str</code></dt>
<dd>nat-traversal.
('enable', 'disable', 'forced', None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nattraversal(self, nattraversal):
    &#34;&#34;&#34; Set self.nat_traversal

    Args:
        nattraversal (str): nat-traversal.  (&#39;enable&#39;, &#39;disable&#39;, &#39;forced&#39;, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if nattraversal is None:
        self.nattraversal = None
    else:
        if isinstance(nattraversal, str):
            if nattraversal.lower() == &#39;enable&#39;:
                self.nattraversal = &#39;enable&#39;
            elif nattraversal.lower() == &#39;disable&#39;:
                self.nattraversal = &#39;disable&#39;
            elif nattraversal.lower() == &#39;forced&#39;:
                self.nattraversal = &#39;forced&#39;
            else:
                raise ValueError(&#34;&#39;nattraversal&#39;, when set, must be type str() with value &#39;enable&#39;, &#39;disable&#39; &#34;
                                &#34;or &#39;forced&#39;&#34;)
        else:
            raise ValueError(&#34;&#39;nattraversal&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_net_device"><code class="name flex">
<span>def <span class="ident">set_net_device</span></span>(<span>self, net_device)</span>
</code></dt>
<dd>
<section class="desc"><p>set self.net_device</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>net_device</code></strong> :&ensp;<code>str</code></dt>
<dd>net-device. ('enable', 'disable' or None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_net_device(self, net_device):
    &#34;&#34;&#34; set self.net_device

    Args:
        net_device (str): net-device. (&#39;enable&#39;, &#39;disable&#39; or None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if net_device is None:
        self.net_device = None
    else:
        if isinstance(net_device, str):
            if net_device == &#39;enable&#39;:
                self.net_device = &#39;enable&#39;
            elif net_device == &#39;disable&#39;:
                self.net_device = &#39;disable&#39;
            else:
                raise ValueError(&#34;&#39;net_device&#39;, when set, must be type str() with value &#39;enable&#39; or &#39;disable&#39;&#34;)
        else:
            raise ValueError(&#34;&#39;net_device&#39;, when set, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_p1_type"><code class="name flex">
<span>def <span class="ident">set_p1_type</span></span>(<span>self, p1_type)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.pt_type to p1_type if p1_type is valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p1_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1-interface type.
('dynamic', 'static', 'ddns' or None=inherit)</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_p1_type(self, p1_type):
    &#34;&#34;&#34; Set self.pt_type to p1_type if p1_type is valid

    Args:
        p1_type (str): Phase1-interface type.  (&#39;dynamic&#39;, &#39;static&#39;, &#39;ddns&#39; or None=inherit)

    Returns:

    &#34;&#34;&#34;
    if p1_type is None:
        self.p1_type = None
    else:
        if isinstance(p1_type, str):
            if p1_type.lower() == &#39;dynamic&#39;:
                self.p1_type = &#39;dynamic&#39;
            elif p1_type.lower() == &#39;static&#39;:
                self.p1_type = &#39;static&#39;
            elif p1_type.lower() == &#39;ddns&#39;:
                raise ValueError(&#34;p1_type of &#39;ddns&#39; is not yet supported&#34;)
            else:
                raise ValueError(f&#34;&#39;p1_type&#39;: {p1_type} is not supported&#34;)
        else:
            raise ValueError(&#34;&#39;p1_type&#39;, when set, must be a str with value of &#39;dynamic&#39; or &#39;static&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_proposal"><code class="name flex">
<span>def <span class="ident">set_proposal</span></span>(<span>self, proposal)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal</code></strong> :&ensp;<code>list</code></dt>
<dd>string containing a single p1 proposal or list of strings with one or more p1 propolsals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_proposal(self, proposal):
    &#34;&#34;&#34; Set self.proposal with list of proposals from proposal if items are all acceptable FG proposals

    Args:
        proposal (list): string containing a single p1 proposal or list of strings with one or more p1 propolsals

    Returns:
        None
    &#34;&#34;&#34;
    valid_proposals = [&#39;des-md5&#39;, &#39;des-sha&#39;, &#39;des-sha256&#39;, &#39;des-sha384&#39;, &#39;des-sha512&#39;, &#39;3des-md5&#39;, &#39;3des-sha1&#39;,
                       &#39;3des-sha256&#39;, &#39;3des-sha384&#39;, &#39;3des-sha512&#39;, &#39;aes128-md5&#39;, &#39;aes128-sha1&#39;, &#39;aes128-sha256&#39;,
                       &#39;aes128-sha384&#39;, &#39;aes128-sha512&#39;, &#39;aes192-md5&#39;, &#39;aes192-sha1&#39;, &#39;aes192-sha256&#39;,
                       &#39;aes192-sha384&#39;, &#39;aes192-sha512&#39;, &#39;aes256-md5&#39;, &#39;aes256-sha1&#39;, &#39;aes256-sha256&#39;,
                       &#39;aes256-sha384&#39;, &#39;aes256-sha512&#39;, &#39;aria128-md5&#39;, &#39;aria128-sha1&#39;, &#39;aria128-sha256&#39;,
                       &#39;aria128-sha384&#39;, &#39;aria128-sha512&#39;, &#39;aria192-md5&#39;, &#39;aria192-sha1&#39;, &#39;aria192-sha256&#39;,
                       &#39;aria192-sha384&#39;, &#39;aria192-sha512&#39;, &#39;aria256-md5&#39;, &#39;aria256-sha1&#39;, &#39;aria256-sha256&#39;,
                       &#39;aria256-sha384&#39;, &#39;aria256-sha512&#39;, &#39;seed-md5&#39;, &#39;seed-sha1&#39;, &#39;seed-sha256&#39;, &#39;seed-sha384&#39;,
                       &#39;seed-sha512&#39;]

    if proposal is None:
        self.proposal = None

    else:
        proposal_items = &#39;&#39;

        # IF a single object was passed as a string, append it to intf_list else iterate the list and pull
        # out the strings of interfaces and append each to intf_list
        if isinstance(proposal, str):

            # compare proposal to valid_proposals list
            if proposal in valid_proposals:
                proposal_items += f&#34;{proposal} &#34;
            else:
                raise ValueError(f&#34;&#39;proposal&#39; provided: {proposal} is not a valid FortiGate phase1 proposal&#34;)

        elif isinstance(proposal, list):
            for item in proposal:
                if isinstance(item, str):

                    # compare proposal to valid proposals list
                    if item in valid_proposals:
                        proposal_items += f&#34;{item} &#34;
                    else:
                        raise ValueError(&#34;&#39;proposal&#39; provided: {proposal} is not a valid FortiGate phase1 proposal&#34;)
        else:
            raise ValueError(&#34;proposal must be provided as type string (with single proposal referenced or as a &#34;
                             &#34;list for multiple proposal references&#34;)

        self.proposal = proposal_items</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_psksecret"><code class="name flex">
<span>def <span class="ident">set_psksecret</span></span>(<span>self, psk)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.psk to psk if psk valid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>psk</code></strong> :&ensp;<code>str</code></dt>
<dd>Phase1 psksecret.
(6 to 30 chars)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_psksecret(self, psk):
    &#34;&#34;&#34; Set self.psk to psk if psk valid

    Args:
        psk (str): Phase1 psksecret.  (6 to 30 chars)

    Returns:
        None
    &#34;&#34;&#34;
    if psk is None:
        self.psksecret = None
    else:
        if isinstance(psk, str):
            if 6 &lt;= len(psk) &lt;= 30:
                self.psksecret = psk
            else:
                raise ValueError(&#34;&#39;psksecret&#39;, must be type str() between 6 and 30 chars&#34;)
        else:
            raise ValueError(&#34;&#39;psksecret&#39;, must be type str()&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_remote_gw"><code class="name flex">
<span>def <span class="ident">set_remote_gw</span></span>(<span>self, remote_gw)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>remote_gw</code></strong> :&ensp;<code>str</code></dt>
<dd>Address of remote vpn peer gateway.
(valid ipv4 address as str())</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_remote_gw(self, remote_gw):
    &#34;&#34;&#34; Set self.remote_gw to remote_gw if remote_gw is valid ipv4 address

    Args:
        remote_gw (str): Address of remote vpn peer gateway.  (valid ipv4 address as str())

    Returns:
        None
    &#34;&#34;&#34;
    if remote_gw is None:
        self.remote_gw = None
    else:
        try:
            self.remote_gw = str(ipaddress.ip_address(remote_gw))
        except ValueError:
            raise ValueError(&#34;&#39;remote_gw&#39;, when set, must be type str() with value containing a valid ipv4 address&#34;)</code></pre>
</details>
</dd>
<dt id="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_tunnel_search"><code class="name flex">
<span>def <span class="ident">set_tunnel_search</span></span>(<span>self, tunnel_search)</span>
</code></dt>
<dd>
<section class="desc"><p>Set self.tunnel_search</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tunnel_search</code></strong> :&ensp;<code>str</code></dt>
<dd>tunnel-search.
('selectors', 'nexthop', None=inherit)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tunnel_search(self, tunnel_search):
    &#34;&#34;&#34; Set self.tunnel_search

    Args:
        tunnel_search (str): tunnel-search.  (&#39;selectors&#39;, &#39;nexthop&#39;, None=inherit)

    Returns:
        None
    &#34;&#34;&#34;
    if tunnel_search is None:
        self.tunnel_search = None
    else:
        if isinstance(tunnel_search, str):
            if tunnel_search.lower() == &#39;selectors&#39;:
                self.tunnel_search = &#39;selectors&#39;
            elif tunnel_search.lower() == &#39;nexthop&#39;:
                self.tunnel_search = &#39;nexthop&#39;
            else:
                raise Exception(&#34;&#39;tunnel_search&#39; when set, must be type str() with value &#39;selectors&#39;, &#39;nexthop&#39;&#34;)
        else:
            raise ValueError(&#34;&#39;tunnel_search&#39;, when set, must be type str(0&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fgobjlib.fg_object.FgObject" href="fg_object.html#fgobjlib.fg_object.FgObject">FgObject</a></b></code>:
<ul class="hlist">
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_add" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_add">get_api_config_add</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_del" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_del">get_api_config_del</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_get" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_get">get_api_config_get</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_api_config_update" href="fg_object.html#fgobjlib.fg_object.FgObject.get_api_config_update">get_api_config_update</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_cli_config_add" href="fg_object.html#fgobjlib.fg_object.FgObject.get_cli_config_add">get_cli_config_add</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_cli_config_del" href="fg_object.html#fgobjlib.fg_object.FgObject.get_cli_config_del">get_cli_config_del</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.get_cli_config_update" href="fg_object.html#fgobjlib.fg_object.FgObject.get_cli_config_update">get_cli_config_update</a></code></li>
<li><code><a title="fgobjlib.fg_object.FgObject.set_vdom" href="fg_object.html#fgobjlib.fg_object.FgObject.set_vdom">set_vdom</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fgobjlib" href="index.html">fgobjlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface">FgIpsecP1Interface</a></code></h4>
<ul class="">
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_gw_route" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_gw_route">set_add_gw_route</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_route" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_add_route">set_add_route</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_comment" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_comment">set_comment</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dhgrp" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dhgrp">set_dhgrp</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dpd" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_dpd">set_dpd</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_exchange_interface_ip" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_exchange_interface_ip">set_exchange_interface_ip</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_ike_version" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_ike_version">set_ike_version</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_interface" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_interface">set_interface</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_keepalive" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_keepalive">set_keepalive</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_gw" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_local_gw">set_local_gw</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_localid" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_localid">set_localid</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_name" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_name">set_name</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_nattraversal" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_nattraversal">set_nattraversal</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_net_device" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_net_device">set_net_device</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_p1_type" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_p1_type">set_p1_type</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_proposal" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_proposal">set_proposal</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_psksecret" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_psksecret">set_psksecret</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_remote_gw" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_remote_gw">set_remote_gw</a></code></li>
<li><code><a title="fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_tunnel_search" href="#fgobjlib.fg_vpn_ipsec_p1_interface.FgIpsecP1Interface.set_tunnel_search">set_tunnel_search</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>